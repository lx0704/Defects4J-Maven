<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_80) on Tue Jun 13 14:53:37 CDT 2017 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Mockito (Mockito 2.0.12-beta API)</title>
<meta name="date" content="2017-06-13">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Mockito (Mockito 2.0.12-beta API)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Mockito.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>
<em id="mockito-version-header-javadoc7"><strong>Mockito 2.0.12-beta API</strong></em>

<!-- using the beautify plugin for jQuery from https://bitbucket.org/larscorneliussen/beautyofcode/ -->
<script type="text/javascript">
  var shBaseURL = "../../js/sh-2.1.382/";
</script>
<script type="text/javascript" src="../../js/jquery-1.7.min.js"></script>
<script type="text/javascript" src="../../js/jquery.beautyOfCode-min.js"></script>

<script type="text/javascript">
  /* Apply beautification of code */
  var usingOldIE = false;
  if($.browser.msie && parseInt($.browser.version) < 9) usingOldIE = true;

  if(!usingOldIE) {
      $.beautyOfCode.init({
        theme : "Eclipse",
        brushes: ["Java"]
      });

      var version = "2.0.12-beta";

      jQuery.fn.removeAttributes = function() {
        return this.each(function() {
          var attributes = $.map(this.attributes, function(item) {
            return item.name;
          });
          var img = $(this);
          $.each(attributes, function(i, item) {
            img.removeAttr(item);
          });
        });
      };

      $(function() {
        /* Add name & version to header for Javadoc 1.6 */
        $("td.NavBarCell1[colspan=2]").each(function(index, element) {
          var jqueryTD = $(element);
          jqueryTD.after(
            $("<td><em><strong>Mockito 2.0.12-beta API</strong></em></td>").attr("class","NavBarCell1").attr("id","mockito-version-header-javadoc6")
          );
          jqueryTD.removeAttr("colspan");
        });
        /* Cleans up mess with Javadoc 1.7 */
        $("body > h1").removeAttributes().attr("class", "bar").attr("title", "Mockito 2.0.12-beta API");
        /* Cleans up mess with Javadoc 1.7 with Javadoc 1.6 */
        $("td em#mockito-version-header-javadoc7").remove();
      });
  }
</script>
</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito"><span class="strong">Prev Class</span></a></li>
<li><a href="../../org/mockito/MockitoAnnotations.html" title="class in org.mockito"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/mockito/Mockito.html" target="_top">Frames</a></li>
<li><a href="Mockito.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.mockito</div>
<h2 title="Class Mockito" class="title">Class Mockito</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li><a href="../../org/mockito/Matchers.html" title="class in org.mockito">org.mockito.Matchers</a></li>
<li>
<ul class="inheritance">
<li>org.mockito.Mockito</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../org/mockito/BDDMockito.html" title="class in org.mockito">BDDMockito</a></dd>
</dl>
<hr>
<br>
<pre>public class <span class="strong">Mockito</span>
extends <a href="../../org/mockito/Matchers.html" title="class in org.mockito">Matchers</a></pre>
<div class="block"><p align="left"><img src="logo.jpg"/></p>
 Mockito library enables mocks creation, verification and stubbing.
 <p>
 This javadoc content is also available on the <a href="http://mockito.org">http://mockito.org</a> web page.
 All documentation is kept in javadocs because it guarantees consistency between what's on the web and what's in the source code.
 Also, it makes possible to access documentation straight from the IDE even if you work offline.

 <h1>Contents</h1>

 <b>
      <a href="#1">1. Let's verify some behaviour! </a><br/>
      <a href="#2">2. How about some stubbing? </a><br/>
      <a href="#3">3. Argument matchers </a><br/>
      <a href="#4">4. Verifying exact number of invocations / at least once / never </a><br/>
      <a href="#5">5. Stubbing void methods with exceptions </a><br/>
      <a href="#6">6. Verification in order </a><br/>
      <a href="#7">7. Making sure interaction(s) never happened on mock </a><br/>
      <a href="#8">8. Finding redundant invocations </a><br/>
      <a href="#9">9. Shorthand for mocks creation - <code>&#064;Mock</code> annotation </a><br/>
      <a href="#10">10. Stubbing consecutive calls (iterator-style stubbing) </a><br/>
      <a href="#11">11. Stubbing with callbacks </a><br/>
      <a href="#12">12. <code>doReturn()</code>|<code>doThrow()</code>|<code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a><br/>
      <a href="#13">13. Spying on real objects </a><br/>
      <a href="#14">14. Changing default return values of unstubbed invocations (Since 1.7) </a><br/>
      <a href="#15">15. Capturing arguments for further assertions (Since 1.8.0) </a><br/>
      <a href="#16">16. Real partial mocks (Since 1.8.0) </a><br/>
      <a href="#17">17. Resetting mocks (Since 1.8.0) </a><br/>
      <a href="#18">18. Troubleshooting & validating framework usage (Since 1.8.0) </a><br/>
      <a href="#19">19. Aliases for behavior driven development (Since 1.8.0) </a><br/>
      <a href="#20">20. Serializable mocks (Since 1.8.1) </a><br/>
      <a href="#21">21. New annotations: <code>&#064;Captor</code>, <code>&#064;Spy</code>, <code>&#064;InjectMocks</code> (Since 1.8.3) </a><br/>
      <a href="#22">22. Verification with timeout (Since 1.8.5) </a><br/>
      <a href="#23">23. Automatic instantiation of <code>&#064;Spies</code>, <code>&#064;InjectMocks</code> and constructor injection goodness (Since 1.9.0)</a><br/>
      <a href="#24">24. One-liner stubs (Since 1.9.0)</a><br/>
      <a href="#25">25. Verification ignoring stubs (Since 1.9.0)</a><br/>
      <a href="#26">26. Mocking details (Since 1.9.5)</a><br/>
      <a href="#27">27. Delegate calls to real instance (Since 1.9.5)</a><br/>
      <a href="#28">28. <code>MockMaker</code> API (Since 1.9.5)</a><br/>
      <a href="#29">29. (new) BDD style verification (Since 1.10.0)</a><br/>
      <a href="#30">30. (new) Spying or mocking abstract classes (Since 1.10.12)</a><br/>
      <a href="#31">31. (new) Mockito mocks can be <em>serialized</em> / <em>deserialized</em> across classloaders (Since 1.10.0)</a></h3>
      <a href="#32">32. (new) Better generic support with deep stubs (Since 1.10.0)</a></h3>
      <a href="#32">33. (new) Mockito JUnit rule (Since 1.10.17)</a><br/>
      <a href="#34">34. (new) Switch <em>on</em> or <em>off</em> plugins (Since 1.10.15)</a><br/>
 </b>

 <p>
 Following examples mock a List, because everyone knows its interface (methods
 like <code>add()</code>, <code>get()</code>, <code>clear()</code> will be used). <br>
 You probably wouldn't mock List class 'in real'.




 <h3 id="1">1. <a class="meaningful_link" href="#verification">Let's verify some behaviour!</a></h3>

 <pre class="code"><code class="java">
 //Let's import Mockito statically so that the code looks clearer
 import static org.mockito.Mockito.*;

 //mock creation
 List mockedList = mock(List.class);

 //using mock object
 mockedList.add("one");
 mockedList.clear();

 //verification
 verify(mockedList).add("one");
 verify(mockedList).clear();
 </code></pre>

 <p>
 Once created, mock will remember all interactions. Then you can selectively
 verify whatever interaction you are interested in.




 <h3 id="2">2. <a class="meaningful_link" href="#stubbing">How about some stubbing?</a></h3>

 <pre class="code"><code class="java">
 //You can mock concrete classes, not only interfaces
 LinkedList mockedList = mock(LinkedList.class);

 //stubbing
 when(mockedList.get(0)).thenReturn("first");
 when(mockedList.get(1)).thenThrow(new RuntimeException());

 //following prints "first"
 System.out.println(mockedList.get(0));

 //following throws runtime exception
 System.out.println(mockedList.get(1));

 //following prints "null" because get(999) was not stubbed
 System.out.println(mockedList.get(999));

 //Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>
 //If your code cares what get(0) returns then something else breaks (often before even verify() gets executed).
 //If your code doesn't care what get(0) returns then it should not be stubbed. Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.
 verify(mockedList).get(0);
 </code></pre>

 <ul>
 <li> By default, for all methods that return value, mock returns null, an
 empty collection or appropriate primitive/primitive wrapper value (e.g: 0,
 false, ... for int/Integer, boolean/Boolean, ...). </li>

 <li> Stubbing can be overridden: for example common stubbing can go to
 fixture setup but the test methods can override it.
 Please note that overridding stubbing is a potential code smell that points out too much stubbing</li>

 <li> Once stubbed, the method will always return stubbed value regardless
 of how many times it is called. </li>

 <li> Last stubbing is more important - when you stubbed the same method with
 the same arguments many times.
 Other words: <b>the order of stubbing matters</b> but it is only meaningful rarely,
 e.g. when stubbing exactly the same method calls or sometimes when argument matchers are used, etc.</li>

 </ul>



 <h3 id="3">3. <a class="meaningful_link" href="#argument_matchers">Argument matchers</a></h3>

 Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.
 Sometimes, when extra flexibility is required then you might use argument matchers:

 <pre class="code"><code class="java">
 //stubbing using built-in anyInt() argument matcher
 when(mockedList.get(anyInt())).thenReturn("element");

 //stubbing using hamcrest (let's say isValid() returns your own hamcrest matcher):
 when(mockedList.contains(argThat(isValid()))).thenReturn("element");

 //following prints "element"
 System.out.println(mockedList.get(999));

 //<b>you can also verify using an argument matcher</b>
 verify(mockedList).get(anyInt());
 </code></pre>

 <p>
 Argument matchers allow flexible verification or stubbing.
 <a href="../../org/mockito/Matchers.html" title="class in org.mockito"><code>Click here to see</code></a> more built-in matchers
 and examples of <b>custom argument matchers / hamcrest matchers</b>.
 <p>
 For information solely on <b>custom argument matchers</b> check out javadoc for <a href="../../org/mockito/ArgumentMatcher.html" title="class in org.mockito"><code>ArgumentMatcher</code></a> class.
 <p>
 Be reasonable with using complicated argument matching.
 The natural matching style using <code>equals()</code> with occasional <code>anyX()</code> matchers tend to give clean & simple tests.
 Sometimes it's just better to refactor the code to allow <code>equals()</code> matching or even implement <code>equals()</code> method to help out with testing.
 <p>
 Also, read <a href="#15">section 15</a> or javadoc for <a href="../../org/mockito/ArgumentCaptor.html" title="class in org.mockito"><code>ArgumentCaptor</code></a> class.
 <a href="../../org/mockito/ArgumentCaptor.html" title="class in org.mockito"><code>ArgumentCaptor</code></a> is a special implementation of an argument matcher that captures argument values for further assertions.
 <p>
 <b>Warning on argument matchers:</b>
 <p>
 If you are using argument matchers, <b>all arguments</b> have to be provided
 by matchers.
 <p>
 E.g: (example shows verification but the same applies to stubbing):

 <pre class="code"><code class="java">
   verify(mock).someMethod(anyInt(), anyString(), <b>eq("third argument")</b>);
   //above is correct - eq() is also an argument matcher

   verify(mock).someMethod(anyInt(), anyString(), <b>"third argument"</b>);
   //above is incorrect - exception will be thrown because third argument is given without an argument matcher.
 </code></pre>

 <p>
 Matcher methods like <code>anyObject()</code>, <code>eq()</code> <b>do not</b> return matchers.
 Internally, they record a matcher on a stack and return a dummy value (usually null).
 This implementation is due static type safety imposed by java compiler.
 The consequence is that you cannot use <code>anyObject()</code>, <code>eq()</code> methods outside of verified/stubbed method.




 <h3 id="4">4. <a class="meaningful_link" href="#exact_verification">Verifying exact number of invocations</a> /
 <a class="meaningful_link" href="#at_least_verification">at least x</a> / never</h3>

 <pre class="code"><code class="java">
 //using mock
 mockedList.add("once");

 mockedList.add("twice");
 mockedList.add("twice");

 mockedList.add("three times");
 mockedList.add("three times");
 mockedList.add("three times");

 //following two verifications work exactly the same - times(1) is used by default
 verify(mockedList).add("once");
 verify(mockedList, times(1)).add("once");

 //exact number of invocations verification
 verify(mockedList, times(2)).add("twice");
 verify(mockedList, times(3)).add("three times");

 //verification using never(). never() is an alias to times(0)
 verify(mockedList, never()).add("never happened");

 //verification using atLeast()/atMost()
 verify(mockedList, atLeastOnce()).add("three times");
 verify(mockedList, atLeast(2)).add("five times");
 verify(mockedList, atMost(5)).add("three times");

 </code></pre>

 <p>
 <b>times(1) is the default.</b> Therefore using times(1) explicitly can be
 omitted.




 <h3 id="5">5. <a class="meaningful_link" href="#stubbing_with_exceptions">Stubbing void methods with exceptions</a></h3>

 <pre class="code"><code class="java">
   doThrow(new RuntimeException()).when(mockedList).clear();

   //following throws RuntimeException:
   mockedList.clear();
 </code></pre>

 Read more about doThrow|doAnswer family of methods in paragraph 12.
 <p>
 Initially, <a href="../../org/mockito/Mockito.html#stubVoid(T)"><code>stubVoid(Object)</code></a> was used for stubbing voids.
 Currently <code>stubVoid()</code> is deprecated in favor of <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a>.
 This is because of improved readability and consistency with the family of <a href="../../org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer)"><code>doAnswer(Answer)</code></a> methods.




 <h3 id="6">6. <a class="meaningful_link" href="#in_order_verification">Verification in order</a></h3>

 <pre class="code"><code class="java">
 // A. Single mock whose methods must be invoked in a particular order
 List singleMock = mock(List.class);

 //using a single mock
 singleMock.add("was added first");
 singleMock.add("was added second");

 //create an inOrder verifier for a single mock
 InOrder inOrder = inOrder(singleMock);

 //following will make sure that add is first called with "was added first, then with "was added second"
 inOrder.verify(singleMock).add("was added first");
 inOrder.verify(singleMock).add("was added second");

 // B. Multiple mocks that must be used in a particular order
 List firstMock = mock(List.class);
 List secondMock = mock(List.class);

 //using mocks
 firstMock.add("was called first");
 secondMock.add("was called second");

 //create inOrder object passing any mocks that need to be verified in order
 InOrder inOrder = inOrder(firstMock, secondMock);

 //following will make sure that firstMock was called before secondMock
 inOrder.verify(firstMock).add("was called first");
 inOrder.verify(secondMock).add("was called second");

 // Oh, and A + B can be mixed together at will
 </code></pre>

 Verification in order is flexible - <b>you don't have to verify all
 interactions</b> one-by-one but only those that you are interested in
 testing in order.
 <p>
 Also, you can create InOrder object passing only mocks that are relevant for
 in-order verification.




 <h3 id="7">7. <a class="meaningful_link" href="#never_verification">Making sure interaction(s) never happened on mock</a></h3>

 <pre class="code"><code class="java">
 //using mocks - only mockOne is interacted
 mockOne.add("one");

 //ordinary verification
 verify(mockOne).add("one");

 //verify that method was never called on a mock
 verify(mockOne, never()).add("two");

 //verify that other mocks were not interacted
 verifyZeroInteractions(mockTwo, mockThree);

 </code></pre>




 <h3 id="8">8. <a class="meaningful_link" href="#finding_redundant_invocations">Finding redundant invocations</a></h3>

 <pre class="code"><code class="java">
 //using mocks
 mockedList.add("one");
 mockedList.add("two");

 verify(mockedList).add("one");

 //following verification will fail
 verifyNoMoreInteractions(mockedList);
 </code></pre>

 A word of <b>warning</b>:
 Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.
 <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.
 <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 Abusing it leads to <strong>overspecified</strong>, <strong>less maintainable</strong> tests. You can find further reading
 <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.

 <p>
 See also <a href="../../org/mockito/Mockito.html#never()"><code>never()</code></a> - it is more explicit and
 communicates the intent well.
 <p>




 <h3 id="9">9. <a class="meaningful_link" href="#mock_annotation">Shorthand for mocks creation - <code>&#064;Mock</code> annotation</a></h3>

 <ul>
 <li>Minimizes repetitive mock creation code.</li>
 <li>Makes the test class more readable.</li>
 <li>Makes the verification error easier to read because the <b>field name</b>
 is used to identify the mock.</li>
 </ul>

 <pre class="code"><code class="java">
   public class ArticleManagerTest {

       &#064;Mock private ArticleCalculator calculator;
       &#064;Mock private ArticleDatabase database;
       &#064;Mock private UserProvider userProvider;

       private ArticleManager manager;
 </code></pre>

 <b>Important!</b> This needs to be somewhere in the base class or a test
 runner:

 <pre class="code"><code class="java">
 MockitoAnnotations.initMocks(testClass);
 </code></pre>

 You can use built-in runner: <a href="../../org/mockito/runners/MockitoJUnitRunner.html" title="class in org.mockito.runners"><code>MockitoJUnitRunner</code></a> or a rule: <a href="../../org/mockito/junit/MockitoRule.html" title="interface in org.mockito.junit"><code>MockitoRule</code></a>.
 <p>
 Read more here: <a href="../../org/mockito/MockitoAnnotations.html" title="class in org.mockito"><code>MockitoAnnotations</code></a>




 <h3 id="10">10. <a class="meaningful_link" href="#stubbing_consecutive_calls">Stubbing consecutive calls</a> (iterator-style stubbing)</h3>

 Sometimes we need to stub with different return value/exception for the same
 method call. Typical use case could be mocking iterators.
 Original version of Mockito did not have this feature to promote simple mocking.
 For example, instead of iterators one could use <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true" title="class or interface in java.lang"><code>Iterable</code></a> or simply
 collections. Those offer natural ways of stubbing (e.g. using real
 collections). In rare scenarios stubbing consecutive calls could be useful,
 though:
 <p>

 <pre class="code"><code class="java">
 when(mock.someMethod("some arg"))
   .thenThrow(new RuntimeException())
   .thenReturn("foo");

 //First call: throws runtime exception:
 mock.someMethod("some arg");

 //Second call: prints "foo"
 System.out.println(mock.someMethod("some arg"));

 //Any consecutive call: prints "foo" as well (last stubbing wins).
 System.out.println(mock.someMethod("some arg"));
 </code></pre>

 Alternative, shorter version of consecutive stubbing:

 <pre class="code"><code class="java">
 when(mock.someMethod("some arg"))
   .thenReturn("one", "two", "three");
 </code></pre>




 <h3 id="11">11. <a class="meaningful_link" href="#answer_stubs">Stubbing with callbacks</a></h3>

 Allows stubbing with generic <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a> interface.
 <p>
 Yet another controversial feature which was not included in Mockito
 originally. We recommend using simple stubbing with <code>thenReturn()</code> or
 <code>thenThrow()</code> only. Those two should be <b>just enough</b> to test/test-drive
 any clean & simple code.

 <pre class="code"><code class="java">
 when(mock.someMethod(anyString())).thenAnswer(new Answer() {
     Object answer(InvocationOnMock invocation) {
         Object[] args = invocation.getArguments();
         Object mock = invocation.getMock();
         return "called with arguments: " + args;
     }
 });

 //Following prints "called with arguments: foo"
 System.out.println(mock.someMethod("foo"));
 </code></pre>




 <h3 id="12">12. <a class="meaningful_link" href="#do_family_methods_stubs"><code>doReturn()</code>|<code>doThrow()</code>|
 <code>doAnswer()</code>|<code>doNothing()</code>|<code>doCallRealMethod()</code> family of methods</a></h3>

 Stubbing voids requires different approach from <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> because the compiler does not
 like void methods inside brackets...
 <p>
 <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a> replaces the <a href="../../org/mockito/Mockito.html#stubVoid(T)"><code>stubVoid(Object)</code></a> method for stubbing voids.
 The main reason is improved readability and consistency with the family of <code>doAnswer()</code> methods.
 <p>
 Use <code>doThrow()</code> when you want to stub a void method with an exception:
 <pre class="code"><code class="java">
   doThrow(new RuntimeException()).when(mockedList).clear();

   //following throws RuntimeException:
   mockedList.clear();
 </code></pre>

 <p>
 You can use <code>doThrow()</code>, <code>doAnswer()</code>, <code>doNothing()</code>, <code>doReturn()</code>
 and <code>doCallRealMethod()</code> in place of the corresponding call with <code>when()</code>, for any method.
 It is necessary when you
 <ul>
     <li>stub void methods</li>
     <li>stub methods on spy objects (see below)</li>
     <li>stub the same method more than once, to change the behaviour of a mock in the middle of a test.</li>
 </ul>
 but you may prefer to use these methods in place of the alternative with <code>when()</code>, for all of your stubbing calls.
 <p>
 Read more about these methods:
 <p>
 <a href="../../org/mockito/Mockito.html#doReturn(java.lang.Object)"><code>doReturn(Object)</code></a>
 <p>
 <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a>
 <p>
 <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Class)"><code>doThrow(Class)</code></a>
 <p>
 <a href="../../org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer)"><code>doAnswer(Answer)</code></a>
 <p>
 <a href="../../org/mockito/Mockito.html#doNothing()"><code>doNothing()</code></a>
 <p>
 <a href="../../org/mockito/Mockito.html#doCallRealMethod()"><code>doCallRealMethod()</code></a>




 <h3 id="13">13. <a class="meaningful_link" href="#spy">Spying on real objects</a></h3>

 You can create spies of real objects. When you use the spy then the <b>real</b> methods are called
 (unless a method was stubbed).
 <p>
 Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.

 <p>
 Spying on real objects can be associated with "partial mocking" concept.
 <b>Before the release 1.8</b>, Mockito spies were not real partial mocks.
 The reason was we thought partial mock is a code smell.
 At some point we found legitimate use cases for partial mocks
 (3rd party interfaces, interim refactoring of legacy code, the full article is <a href=
 "http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring"
 >here</a>)
 <p>

 <pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //optionally, you can stub out some methods:
   when(spy.size()).thenReturn(100);

   //using the spy calls <b>*real*</b> methods
   spy.add("one");
   spy.add("two");

   //prints "one" - the first element of a list
   System.out.println(spy.get(0));

   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());

   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
 </code></pre>

 <h4>Important gotcha on spying real objects!</h4>
 <ol>
 <li>Sometimes it's impossible or impractical to use <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> for stubbing spies.
 Therefore when using spies please consider <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code> family of
 methods for stubbing. Example:

 <pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo");

   //You have to use doReturn() for stubbing
   doReturn("foo").when(spy).get(0);
 </code></pre>
 </li>

 <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.
 So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
 and their effect on real instance state.
 The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,
 you won't see any effects on the real instance.
 </li>

 <li>Watch out for final methods.
 Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
 Also you won't be able to verify those method as well.
 </li>
 </ol>




 <h3 id="14">14. Changing <a class="meaningful_link" href="#defaultreturn">default return values of unstubbed invocations</a> (Since 1.7)</h3>

 You can create a mock with specified strategy for its return values.
 It's quite advanced feature and typically you don't need it to write decent tests.
 However, it can be helpful for working with <b>legacy systems</b>.
 <p>
 It is the default answer so it will be used <b>only when you don't</b> stub the method call.

 <pre class="code"><code class="java">
   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 </code></pre>

 <p>
 Read more about this interesting implementation of <i>Answer</i>: <a href="../../org/mockito/Mockito.html#RETURNS_SMART_NULLS"><code>RETURNS_SMART_NULLS</code></a>




 <h3 id="15">15. <a class="meaningful_link" href="#captors">Capturing arguments</a> for further assertions (Since 1.8.0)</h3>

 Mockito verifies argument values in natural java style: by using an <code>equals()</code> method.
 This is also the recommended way of matching arguments because it makes tests clean & simple.
 In some situations though, it is helpful to assert on certain arguments after the actual verification.
 For example:
 <pre class="code"><code class="java">
   ArgumentCaptor&lt;Person&gt; argument = ArgumentCaptor.forClass(Person.class);
   verify(mock).doSomething(argument.capture());
   assertEquals("John", argument.getValue().getName());
 </code></pre>

 <b>Warning:</b> it is recommended to use ArgumentCaptor with verification <b>but not</b> with stubbing.
 Using ArgumentCaptor with stubbing may decrease test readability because captor is created outside of assert (aka verify or 'then') block.
 Also it may reduce defect localization because if stubbed method was not called then no argument is captured.
 <p>
 In a way ArgumentCaptor is related to custom argument matchers (see javadoc for <a href="../../org/mockito/ArgumentMatcher.html" title="class in org.mockito"><code>ArgumentMatcher</code></a> class).
 Both techniques can be used for making sure certain arguments where passed to mocks.
 However, ArgumentCaptor may be a better fit if:
 <ul>
 <li>custom argument matcher is not likely to be reused</li>
 <li>you just need it to assert on argument values to complete verification</li>
 </ul>
 Custom argument matchers via <a href="../../org/mockito/ArgumentMatcher.html" title="class in org.mockito"><code>ArgumentMatcher</code></a> are usually better for stubbing.




 <h3 id="16">16. <a class="meaningful_link" href="#partial_mocks">Real partial mocks</a> (Since 1.8.0)</h3>

  Finally, after many internal debates & discussions on the mailing list, partial mock support was added to Mockito.
  Previously we considered partial mocks as code smells. However, we found a legitimate use case for partial mocks - more reading:
  <a href="http://monkeyisland.pl/2009/01/13/subclass-and-override-vs-partial-mocking-vs-refactoring">here</a>
  <p>
  <b>Before release 1.8</b> <code>spy()</code> was not producing real partial mocks and it was confusing for some users.
  Read more about spying: <a href="#13">here</a> or in javadoc for <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a> method.
  <p>
  <pre class="code"><code class="java">
    //you can create partial mock with spy() method:
    List list = spy(new LinkedList());

    //you can enable partial mock capabilities selectively on mocks:
    Foo mock = mock(Foo.class);
    //Be sure the real implementation is 'safe'.
    //If real implementation throws exceptions or depends on specific state of the object then you're in trouble.
    when(mock.someMethod()).thenCallRealMethod();
  </code></pre>

 As usual you are going to read <b>the partial mock warning</b>:
 Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 How does partial mock fit into this paradigm? Well, it just doesn't...
 Partial mock usually means that the complexity has been moved to a different method on the same object.
 In most cases, this is not the way you want to design your application.
 <p>
 However, there are rare cases when partial mocks come handy:
 dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 However, I wouldn't use partial mocks for new, test-driven & well-designed code.




 <h3 id="17">17. <a class="meaningful_link" href="#resetting_mocks">Resetting mocks</a> (Since 1.8.0)</h3>

 Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
 Normally, you don't need to reset your mocks, just create new mocks for each test method.
 <p>
 Instead of <code>reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.
 <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.
 Follow the whisper of your test methods: "Please keep us small & focused on single behavior".
 There are several threads about it on mockito mailing list.
 <p>
 The only reason we added <code>reset()</code> method is to
 make it possible to work with container-injected mocks.
 See issue 55 (<a href="http://code.google.com/p/mockito/issues/detail?id=55">here</a>)
 or FAQ (<a href="http://code.google.com/p/mockito/wiki/FAQ">here</a>).
 <p>
 <b>Don't harm yourself.</b> <code>reset()</code> in the middle of the test method is a code smell (you're probably testing too much).
 <pre class="code"><code class="java">
   List mock = mock(List.class);
   when(mock.size()).thenReturn(10);
   mock.add(1);

   reset(mock);
   //at this point the mock forgot any interactions & stubbing
 </code></pre>




 <h3 id="18">18. <a class="meaningful_link" href="#framework_validation">Troubleshooting & validating framework usage</a> (Since 1.8.0)</h3>

 First of all, in case of any trouble, I encourage you to read the Mockito FAQ:
 <a href="http://code.google.com/p/mockito/wiki/FAQ">http://code.google.com/p/mockito/wiki/FAQ</a>
 <p>
 In case of questions you may also post to mockito mailing list:
 <a href="http://groups.google.com/group/mockito">http://groups.google.com/group/mockito</a>
 <p>
 Next, you should know that Mockito validates if you use it correctly <b>all the time</b>.
 However, there's a gotcha so please read the javadoc for <a href="../../org/mockito/Mockito.html#validateMockitoUsage()"><code>validateMockitoUsage()</code></a>




 <h3 id="19">19. <a class="meaningful_link" href="#bdd_mockito">Aliases for behavior driven development</a> (Since 1.8.0)</h3>

 Behavior Driven Development style of writing tests uses <b>//given //when //then</b> comments as fundamental parts of your test methods.
 This is exactly how we write our tests and we warmly encourage you to do so!
 <p>
 Start learning about BDD here: <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">http://en.wikipedia.org/wiki/Behavior_Driven_Development</a>
 <p>
 The problem is that current stubbing api with canonical role of <b>when</b> word does not integrate nicely with <b>//given //when //then</b> comments.
 It's because stubbing belongs to <b>given</b> component of the test and not to the <b>when</b> component of the test.
 Hence <a href="../../org/mockito/BDDMockito.html" title="class in org.mockito"><code>BDDMockito</code></a> class introduces an alias so that you stub method calls with <a href="../../org/mockito/BDDMockito.html#given(T)"><code>BDDMockito.given(Object)</code></a> method.
 Now it really nicely integrates with the <b>given</b> component of a BDD style test!
 <p>
 Here is how the test might look like:
 <pre class="code"><code class="java">
 import static org.mockito.BDDMockito.*;

 Seller seller = mock(Seller.class);
 Shop shop = new Shop(seller);

 public void shouldBuyBread() throws Exception {
   //given
   given(seller.askForBread()).willReturn(new Bread());

   //when
   Goods goods = shop.buyBread();

   //then
   assertThat(goods, containBread());
 }
 </code></pre>




 <h3 id="20">20. <a class="meaningful_link" href="#serializable_mocks">Serializable mocks</a> (Since 1.8.1)</h3>

 Mocks can be made serializable. With this feature you can use a mock in a place that requires dependencies to be serializable.
 <p>
 WARNING: This should be rarely used in unit testing.
 <p>
 The behaviour was implemented for a specific use case of a BDD spec that had an unreliable external dependency.  This
 was in a web environment and the objects from the external dependency were being serialized to pass between layers.
 <p>
 To create serializable mock use <a href="../../org/mockito/MockSettings.html#serializable()"><code>MockSettings.serializable()</code></a>:
 <pre class="code"><code class="java">
   List serializableMock = mock(List.class, withSettings().serializable());
 </code></pre>
 <p>
 The mock can be serialized assuming all the normal <a href='http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html'>
 serialization requirements</a> are met by the class.
 <p>
 Making a real object spy serializable is a bit more effort as the spy(...) method does not have an overloaded version
 which accepts MockSettings. No worries, you will hardly ever use it.

 <pre class="code"><code class="java">
 List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
 List&lt;Object&gt; spy = mock(ArrayList.class, withSettings()
                 .spiedInstance(list)
                 .defaultAnswer(CALLS_REAL_METHODS)
                 .serializable());
 </code></pre>




 <h3 id="21">21. New annotations: <a class="meaningful_link" href="#captor_annotation"><code>&#064;Captor</code></a>,
 <a class="meaningful_link" href="#spy_annotation"><code>&#064;Spy</code></a>,
 <a class="meaningful_link" href="#injectmocks_annotation"><code>&#064;InjectMocks</code></a> (Since 1.8.3)</h3>

 <p>
 Release 1.8.3 brings new annotations that may be helpful on occasion:

 <ul>
 <li>&#064;<a href="../../org/mockito/Captor.html" title="annotation in org.mockito"><code>Captor</code></a> simplifies creation of <a href="../../org/mockito/ArgumentCaptor.html" title="class in org.mockito"><code>ArgumentCaptor</code></a>
 - useful when the argument to capture is a nasty generic class and you want to avoid compiler warnings
 <li>&#064;<a href="../../org/mockito/Spy.html" title="annotation in org.mockito"><code>Spy</code></a> - you can use it instead <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a>.
 <li>&#064;<a href="../../org/mockito/InjectMocks.html" title="annotation in org.mockito"><code>InjectMocks</code></a> - injects mock or spy fields into tested object automatically.
 </ul>

 <p>
 Note that &#064;<a href="../../org/mockito/InjectMocks.html" title="annotation in org.mockito"><code>InjectMocks</code></a> can also be used in combination with the &#064;<a href="../../org/mockito/Spy.html" title="annotation in org.mockito"><code>Spy</code></a> annotation, it means
 that Mockito will inject mocks into the partial mock under test. This complexity is another good reason why you
 should only use partial mocks as a last resort. See point 16 about partial mocks.

 <p>
 All new annotations are <b>*only*</b> processed on <a href="../../org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)"><code>MockitoAnnotations.initMocks(Object)</code></a>.
 Just like for &#064;<a href="../../org/mockito/Mock.html" title="annotation in org.mockito"><code>Mock</code></a> annotation you can use the built-in runner: <a href="../../org/mockito/runners/MockitoJUnitRunner.html" title="class in org.mockito.runners"><code>MockitoJUnitRunner</code></a> or rule:
 <a href="../../org/mockito/junit/MockitoRule.html" title="interface in org.mockito.junit"><code>MockitoRule</code></a>.
 <p>




 <h3 id="22">22. <a class="meaningful_link" href="#verification_timeout">Verification with timeout</a> (Since 1.8.5)</h3>
 <p>
 Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired
 interaction rather than fails immediately if had not already happened. May be useful for testing in concurrent
 conditions.
 <p>
 It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system.
 <p>
 Not yet implemented to work with InOrder verification.
 <p>
 Examples:
 <p>
 <pre class="code"><code class="java">
   //passes when someMethod() is called within given time span
   verify(mock, timeout(100)).someMethod();
   //above is an alias to:
   verify(mock, timeout(100).times(1)).someMethod();

   //passes when someMethod() is called <b>*exactly*</b> 2 times within given time span
   verify(mock, timeout(100).times(2)).someMethod();

   //passes when someMethod() is called <b>*at least*</b> 2 times within given time span
   verify(mock, timeout(100).atLeast(2)).someMethod();

   //verifies someMethod() within given time span using given verification mode
   //useful only if you have your own custom verification modes.
   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();
 </code></pre>




 <h3 id="23">23. <a class="meaningful_link" href="#automatic_instantiation">Automatic instantiation of <code>&#064;Spies</code>,
 <code>&#064;InjectMocks</code></a> and <a class="meaningful_link" href="#constructor_injection">constructor injection goodness</a> (Since 1.9.0)</h3>

 <p>
 Mockito will now try to instantiate &#064;<a href="../../org/mockito/Spy.html" title="annotation in org.mockito"><code>Spy</code></a> and will instantiate &#064;<a href="../../org/mockito/InjectMocks.html" title="annotation in org.mockito"><code>InjectMocks</code></a> fields
 using <b>constructor</b> injection, <b>setter</b> injection, or <b>field</b> injection.
 <p>
 To take advantage of this feature you need to use <a href="../../org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)"><code>MockitoAnnotations.initMocks(Object)</code></a>, <a href="../../org/mockito/runners/MockitoJUnitRunner.html" title="class in org.mockito.runners"><code>MockitoJUnitRunner</code></a>
 or <a href="../../org/mockito/junit/MockitoRule.html" title="interface in org.mockito.junit"><code>MockitoRule</code></a>.
 <p>
 Read more about available tricks and the rules of injection in the javadoc for <a href="../../org/mockito/InjectMocks.html" title="annotation in org.mockito"><code>InjectMocks</code></a>
 <pre class="code"><code class="java">
 //instead:
 &#064;Spy BeerDrinker drinker = new BeerDrinker();
 //you can write:
 &#064;Spy BeerDrinker drinker;

 //same applies to &#064;InjectMocks annotation:
 &#064;InjectMocks LocalPub;
 </code></pre>




 <h3 id="24">24. <a class="meaningful_link" href="#one_liner_stub">One-liner stubs</a> (Since 1.9.0)</h3>
 <p>
 Mockito will now allow you to create mocks when stubbing.
 Basically, it allows to create a stub in one line of code.
 This can be helpful to keep test code clean.
 For example, some boring stub can be created & stubbed at field initialization in a test:
 <pre class="code"><code class="java">
 public class CarTest {
   Car boringStubbedCar = when(mock(Car.class).shiftGear()).thenThrow(EngineNotStarted.class).getMock();

   &#064;Test public void should... {}
 </code></pre>




 <h3 id="25">25. <a class="meaningful_link" href="#ignore_stubs_verification">Verification ignoring stubs</a> (Since 1.9.0)</h3>
 <p>
 Mockito will now allow to ignore stubbing for the sake of verification.
 Sometimes useful when coupled with <code>verifyNoMoreInteractions()</code> or verification <code>inOrder()</code>.
 Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
 <p>
 <b>Warning</b>, <code>ignoreStubs()</code> might lead to overuse of verifyNoMoreInteractions(ignoreStubs(...));
 Bear in mind that Mockito does not recommend bombarding every test with <code>verifyNoMoreInteractions()</code>
 for the reasons outlined in javadoc for <a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)"><code>verifyNoMoreInteractions(Object...)</code></a>
 <p>Some examples:
 <pre class="code"><code class="java">
 verify(mock).foo();
 verify(mockTwo).bar();

 //ignores all stubbed methods:
 verifyNoMoreInvocations(ignoreStubs(mock, mockTwo));

 //creates InOrder that will ignore stubbed
 InOrder inOrder = inOrder(ignoreStubs(mock, mockTwo));
 inOrder.verify(mock).foo();
 inOrder.verify(mockTwo).bar();
 inOrder.verifyNoMoreInteractions();
 </code></pre>
 <p>
 Advanced examples and more details can be found in javadoc for <a href="../../org/mockito/Mockito.html#ignoreStubs(java.lang.Object...)"><code>ignoreStubs(Object...)</code></a>




 <h3 id="26">26. <a class="meaningful_link" href="#mocking_details">Mocking details</a> (Since 1.9.5)</h3>
 <p>
 To identify whether a particular object is a mock or a spy:
 <pre class="code"><code class="java">
     Mockito.mockingDetails(someObject).isMock();
     Mockito.mockingDetails(someObject).isSpy();
 </code></pre>
 Both the <a href="../../org/mockito/MockingDetails.html#isMock()"><code>MockingDetails.isMock()</code></a> and <a href="../../org/mockito/MockingDetails.html#isSpy()"><code>MockingDetails.isSpy()</code></a> methods return <code>boolean</code>.
 As a spy is just a different kind of mock, <code>isMock()</code> returns true if the object is a spy.
 In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
 e.g. invocations, stubbing info, etc.




 <h3 id="27">27. <a class="meaningful_link" href="#delegating_call_to_real_instance">Delegate calls to real instance</a> (Since 1.9.5)</h3>

 <p>Useful for spies or partial mocks of objects <strong>that are difficult to mock or spy</strong> using the usual spy API.
 Since Mockito 1.10.11, the delegate may or may not be of the same type as the mock.
 If the type is different, a matching method needs to be found on delegate type otherwise an exception is thrown.

 Possible use cases for this feature:
 <ul>
     <li>Final classes but with an interface</li>
     <li>Already custom proxied object</li>
     <li>Special objects with a finalize method, i.e. to avoid executing it 2 times</li>
 </ul>

 <p>The difference with the regular spy:
 <ul>
   <li>
     The regular spy (<a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a>) contains <strong>all</strong> state from the spied instance
     and the methods are invoked on the spy. The spied instance is only used at mock creation to copy the state from.
     If you call a method on a regular spy and it internally calls other methods on this spy, those calls are remembered
     for verifications, and they can be effectively stubbed.
   </li>
   <li>
     The mock that delegates simply delegates all methods to the delegate.
     The delegate is used all the time as methods are delegated onto it.
     If you call a method on a mock that delegates and it internally calls other methods on this mock,
     those calls are <strong>not</strong> remembered for verifications, stubbing does not have effect on them, too.
     Mock that delegates is less powerful than the regular spy but it is useful when the regular spy cannot be created.
   </li>
 </ul>

 <p>
 See more information in docs for <a href="../../org/mockito/AdditionalAnswers.html#delegatesTo(java.lang.Object)"><code>AdditionalAnswers.delegatesTo(Object)</code></a>.




 <h3 id="28">28. <a class="meaningful_link" href="#mock_maker_plugin"><code>MockMaker</code> API</a> (Since 1.9.5)</h3>
 <p>Driven by requirements and patches from Google Android guys Mockito now offers an extension point
   that allows replacing the proxy generation engine. By default, Mockito uses cglib to create dynamic proxies.
 <p>The extension point is for advanced users that want to extend Mockito. For example, it is now possible
   to use Mockito for Android testing with a help of dexmaker.
 <p>For more details, motivations and examples please refer to
 the docs for <a href="../../org/mockito/plugins/MockMaker.html" title="interface in org.mockito.plugins"><code>MockMaker</code></a>.




 <h3 id="29">29. <a class="meaningful_link" href="#BDD_behavior_verification">(new) BDD style verification</a> (Since 1.10.0)</h3>

 Enables Behavior Driven Development (BDD) style verification by starting verification with the BDD <b>then</b> keyword.

 <pre class="code"><code class="java">
 given(dog.bark()).willReturn(2);

 // when
 ...

 then(person).should(times(2)).ride(bike);
 </code></pre>

 For more information and an example see <a href="../../org/mockito/BDDMockito.html#then(T)"><code>BDDMockito.then(Object)</code></a>}




 <h3 id="30">30. <a class="meaningful_link" href="#spying_abstract_classes">(new) Spying or mocking abstract classes (Since 1.10.12)</a></h3>

 It is now possible to conveniently spy on abstract classes. Note that overusing spies hints at code design smells (see <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a>).
 <p>
 Previously, spying was only possible on instances of objects.
 New API makes it possible to use constructor when creating an instance of the mock.
 This is particularly useful for mocking abstract classes because the user is no longer required to provide an instance of the abstract class.
 At the moment, only parameter-less constructor is supported, let us know if it is not enough.

 <pre class="code"><code class="java">
 //convenience API, new overloaded spy() method:
 SomeAbstract spy = spy(SomeAbstract.class);

 //Robust API, via settings builder:
 OtherAbstract spy = mock(OtherAbstract.class, withSettings()
    .useConstructor().defaultAnswer(CALLS_REAL_METHODS));

 //Mocking a non-static inner abstract class:
 InnerAbstract spy = mock(InnerAbstract.class, withSettings()
    .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
 </code></pre>

 For more information please see <a href="../../org/mockito/MockSettings.html#useConstructor()"><code>MockSettings.useConstructor()</code></a>.




 <h3 id="31">31. <a class="meaningful_link" href="#serilization_across_classloader">(new) Mockito mocks can be <em>serialized</em> / <em>deserialized</em> across classloaders (Since 1.10.0)</a></h3>

 Mockito introduces serialization across classloader.

 Like with any other form of serialization, all types in the mock hierarchy have to serializable, inclusing answers.
 As this serialization mode require considerably more work, this is an opt-in setting.

 <pre class="code"><code class="java">
 // use regular serialization
 mock(Book.class, withSettings().serializable());

 // use serialization across classloaders
 mock(Book.class, withSettings().serializable(ACROSS_CLASSLOADERS));
 </code></pre>

 For more details see <a href="../../org/mockito/MockSettings.html#serializable(org.mockito.mock.SerializableMode)"><code>MockSettings.serializable(SerializableMode)</code></a>.




 <h3 id="32">32. <a class="meaningful_link" href="#better_generic_support_with_deep_stubs">(new) Better generic support with deep stubs (Since 1.10.0)</a></h3>

 Deep stubbing has been improved to find generic information if available in the class.
 That means that classes like this can be used without having to mock the behavior.

 <pre class="code"><code class="java">
 class Lines extends List&lt;Line&gt; {
     // ...
 }

 lines = mock(Lines.class, RETURNS_DEEP_STUBS);

 // Now Mockito understand this is not an Object but a Line
 Line line = lines.iterator().next();
 </code></pre>

 Please note that in most scenarios a mock returning a mock is wrong.




 <h3 id="33">33. <a class="meaningful_link" href="#mockito_junit_rule">(new) Mockito JUnit rule (Since 1.10.17)</a></h3>

 Mockito now offers a JUnit rule. Until now in JUnit there was two wasy to initialize fields annotated by Mockito annotations
 such as <code>&#064;<a href="../../org/mockito/Mock.html" title="annotation in org.mockito"><code>Mock</code></a></code>, <code>&#064;<a href="../../org/mockito/Spy.html" title="annotation in org.mockito"><code>Spy</code></a></code>, <code>&#064;<a href="../../org/mockito/InjectMocks.html" title="annotation in org.mockito"><code>InjectMocks</code></a></code>, etc.

 <ul>
     <li>Annotating the JUnit test class with a <code>&#064;<code>RunWith</code>(&#064;<a href="../../org/mockito/runners/MockitoJUnitRunner.html" title="class in org.mockito.runners"><code>MockitoJUnitRunner</code></a>.class)</code></li>
     <li>Invoking <code><a href="../../org/mockito/MockitoAnnotations.html#initMocks(java.lang.Object)"><code>MockitoAnnotations.initMocks(Object)</code></a></code> in the <code>&#064;<code>Before</code></code> method</li>
 </ul>

 Now you can choose to use a rule :

 <pre class="code"><code class="java">
 &#064;RunWith(YetAnotherRunner.class)
 public class TheTest {
     &#064;Rule public MockitoRule mockito = MockitoJUnit.rule();
     // ...
 }
 </code></pre>

 For more information see <a href="../../org/mockito/junit/MockitoJUnit.html#rule()"><code>MockitoJUnit.rule()</code></a>.




 <h3 id="34">34. <a class="meaningful_link" href="#plugin_switch">(new) Switch <em>on</em> or <em>off</em> plugins (Since 1.10.15)</a></h3>

 An incubating feature made it's way in mockito that will allow to toggle a mockito-plugin.

 More information here <a href="../../org/mockito/plugins/PluginSwitch.html" title="interface in org.mockito.plugins"><code>PluginSwitch</code></a>.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#CALLS_REAL_METHODS">CALLS_REAL_METHODS</a></strong></code>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#RETURNS_DEEP_STUBS">RETURNS_DEEP_STUBS</a></strong></code>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#RETURNS_DEFAULTS">RETURNS_DEFAULTS</a></strong></code>
<div class="block">The default <code>Answer</code> of every mock <b>if</b> the mock was not stubbed.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#RETURNS_MOCKS">RETURNS_MOCKS</a></strong></code>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#RETURNS_SMART_NULLS">RETURNS_SMART_NULLS</a></strong></code>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../org/mockito/Mockito.html#Mockito()">Mockito</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationAfterDelay.html" title="interface in org.mockito.verification">VerificationAfterDelay</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#after(long)">after</a></strong>(long&nbsp;millis)</code>
<div class="block">Allows verifying over a given period.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#atLeast(int)">atLeast</a></strong>(int&nbsp;minNumberOfInvocations)</code>
<div class="block">Allows at-least-x verification.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#atLeastOnce()">atLeastOnce</a></strong>()</code>
<div class="block">Allows at-least-once verification.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#atMost(int)">atMost</a></strong>(int&nbsp;maxNumberOfInvocations)</code>
<div class="block">Allows at-most-x verification.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#calls(int)">calls</a></strong>(int&nbsp;wantedNumberOfInvocations)</code>
<div class="block">Allows non-greedy verification in order.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#doAnswer(org.mockito.stubbing.Answer)">doAnswer</a></strong>(<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&nbsp;answer)</code>
<div class="block">Use <code>doAnswer()</code> when you want to stub a void method with generic <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#doCallRealMethod()">doCallRealMethod</a></strong>()</code>
<div class="block">Use <code>doCallRealMethod()</code> when you want to call the real implementation of a method.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#doNothing()">doNothing</a></strong>()</code>
<div class="block">Use <code>doNothing()</code> for setting void methods to do nothing.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#doReturn(java.lang.Object)">doReturn</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toBeReturned)</code>
<div class="block">Use <code>doReturn()</code> in those rare occasions when you cannot use <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#doThrow(java.lang.Class)">doThrow</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;? extends <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&gt;&nbsp;toBeThrown)</code>
<div class="block">Use <code>doThrow()</code> when you want to stub the void method to throw exception of specified class.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)">doThrow</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&nbsp;toBeThrown)</code>
<div class="block">Use <code>doThrow()</code> when you want to stub the void method with an exception.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#ignoreStubs(java.lang.Object...)">ignoreStubs</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</code>
<div class="block">Ignores stubbed methods of given mocks for the sake of verification.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/InOrder.html" title="interface in org.mockito">InOrder</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#inOrder(java.lang.Object...)">inOrder</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</code>
<div class="block">Creates <a href="../../org/mockito/InOrder.html" title="interface in org.mockito"><code>InOrder</code></a> object that allows verifying mocks in order.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#mock(java.lang.Class)">mock</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock)</code>
<div class="block">Creates mock object of given class or interface.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)">mock</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
    <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&nbsp;defaultAnswer)</code>
<div class="block">Creates mock with a specified strategy for its answers to interactions.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.MockSettings)">mock</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
    <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a>&nbsp;mockSettings)</code>
<div class="block">Creates a mock with some non-standard settings.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.ReturnValues)">mock</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
    <a href="../../org/mockito/ReturnValues.html" title="interface in org.mockito">ReturnValues</a>&nbsp;returnValues)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i><b>Please use mock(Foo.class, defaultAnswer);</b></i></div>
</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20java.lang.String)">mock</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
    <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name)</code>
<div class="block">Specifies mock name.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito">MockingDetails</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#mockingDetails(java.lang.Object)">mockingDetails</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toInspect)</code>
<div class="block">Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#never()">never</a></strong>()</code>
<div class="block">Alias to <code>times(0)</code>, see <a href="../../org/mockito/Mockito.html#times(int)"><code>times(int)</code></a></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#only()">only</a></strong>()</code>
<div class="block">Allows checking if given method was the only one invoked.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;void</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#reset(T...)">reset</a></strong>(T...&nbsp;mocks)</code>
<div class="block">Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#spy(java.lang.Class)">spy</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToSpy)</code>
<div class="block">Please refer to the documentation of <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#spy(T)">spy</a></strong>(T&nbsp;object)</code>
<div class="block">Creates a spy of the real object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/DeprecatedOngoingStubbing.html" title="interface in org.mockito.stubbing">DeprecatedOngoingStubbing</a>&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#stub(T)">stub</a></strong>(T&nbsp;methodCall)</code>
<div class="block">Stubs a method call with return value or an exception.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/VoidMethodStubbable.html" title="interface in org.mockito.stubbing">VoidMethodStubbable</a>&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#stubVoid(T)">stubVoid</a></strong>(T&nbsp;mock)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Use <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a> method for stubbing voids</i></div>
</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationWithTimeout.html" title="interface in org.mockito.verification">VerificationWithTimeout</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#timeout(long)">timeout</a></strong>(long&nbsp;millis)</code>
<div class="block">Allows verifying with timeout.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#times(int)">times</a></strong>(int&nbsp;wantedNumberOfInvocations)</code>
<div class="block">Allows verifying exact number of invocations.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#validateMockitoUsage()">validateMockitoUsage</a></strong>()</code>
<div class="block">First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href="http://code.google.com/p/mockito/wiki/FAQ">http://code.google.com/p/mockito/wiki/FAQ</a></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#verify(T)">verify</a></strong>(T&nbsp;mock)</code>
<div class="block">Verifies certain behavior <b>happened once</b>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;T</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#verify(T,%20org.mockito.verification.VerificationMode)">verify</a></strong>(T&nbsp;mock,
      <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;mode)</code>
<div class="block">Verifies certain behavior happened at least once / exact number of times / never.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)">verifyNoMoreInteractions</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</code>
<div class="block">Checks if any of given mocks has any unverified interaction.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)">verifyZeroInteractions</a></strong>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</code>
<div class="block">Verifies that no interactions happened on given mocks.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/OngoingStubbing.html" title="interface in org.mockito.stubbing">OngoingStubbing</a>&lt;T&gt;</code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#when(T)">when</a></strong>(T&nbsp;methodCall)</code>
<div class="block">Enables stubbing methods.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a></code></td>
<td class="colLast"><code><strong><a href="../../org/mockito/Mockito.html#withSettings()">withSettings</a></strong>()</code>
<div class="block">Allows mock creation with additional mock settings.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_org.mockito.Matchers">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;org.mockito.<a href="../../org/mockito/Matchers.html" title="class in org.mockito">Matchers</a></h3>
<code><a href="../../org/mockito/Matchers.html#any()">any</a>, <a href="../../org/mockito/Matchers.html#any(java.lang.Class)">any</a>, <a href="../../org/mockito/Matchers.html#anyBoolean()">anyBoolean</a>, <a href="../../org/mockito/Matchers.html#anyByte()">anyByte</a>, <a href="../../org/mockito/Matchers.html#anyChar()">anyChar</a>, <a href="../../org/mockito/Matchers.html#anyCollection()">anyCollection</a>, <a href="../../org/mockito/Matchers.html#anyCollectionOf(java.lang.Class)">anyCollectionOf</a>, <a href="../../org/mockito/Matchers.html#anyDouble()">anyDouble</a>, <a href="../../org/mockito/Matchers.html#anyFloat()">anyFloat</a>, <a href="../../org/mockito/Matchers.html#anyInt()">anyInt</a>, <a href="../../org/mockito/Matchers.html#anyList()">anyList</a>, <a href="../../org/mockito/Matchers.html#anyListOf(java.lang.Class)">anyListOf</a>, <a href="../../org/mockito/Matchers.html#anyLong()">anyLong</a>, <a href="../../org/mockito/Matchers.html#anyMap()">anyMap</a>, <a href="../../org/mockito/Matchers.html#anyMapOf(java.lang.Class,%20java.lang.Class)">anyMapOf</a>, <a href="../../org/mockito/Matchers.html#anyObject()">anyObject</a>, <a href="../../org/mockito/Matchers.html#anySet()">anySet</a>, <a href="../../org/mockito/Matchers.html#anySetOf(java.lang.Class)">anySetOf</a>, <a href="../../org/mockito/Matchers.html#anyShort()">anyShort</a>, <a href="../../org/mockito/Matchers.html#anyString()">anyString</a>, <a href="../../org/mockito/Matchers.html#anyVararg()">anyVararg</a>, <a href="../../org/mockito/Matchers.html#argThat(org.hamcrest.Matcher)">argThat</a>, <a href="../../org/mockito/Matchers.html#booleanThat(org.hamcrest.Matcher)">booleanThat</a>, <a href="../../org/mockito/Matchers.html#byteThat(org.hamcrest.Matcher)">byteThat</a>, <a href="../../org/mockito/Matchers.html#charThat(org.hamcrest.Matcher)">charThat</a>, <a href="../../org/mockito/Matchers.html#contains(java.lang.String)">contains</a>, <a href="../../org/mockito/Matchers.html#doubleThat(org.hamcrest.Matcher)">doubleThat</a>, <a href="../../org/mockito/Matchers.html#endsWith(java.lang.String)">endsWith</a>, <a href="../../org/mockito/Matchers.html#eq(boolean)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(byte)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(char)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(double)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(float)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(int)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(long)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(short)">eq</a>, <a href="../../org/mockito/Matchers.html#eq(T)">eq</a>, <a href="../../org/mockito/Matchers.html#floatThat(org.hamcrest.Matcher)">floatThat</a>, <a href="../../org/mockito/Matchers.html#intThat(org.hamcrest.Matcher)">intThat</a>, <a href="../../org/mockito/Matchers.html#isA(java.lang.Class)">isA</a>, <a href="../../org/mockito/Matchers.html#isNotNull()">isNotNull</a>, <a href="../../org/mockito/Matchers.html#isNotNull(java.lang.Class)">isNotNull</a>, <a href="../../org/mockito/Matchers.html#isNull()">isNull</a>, <a href="../../org/mockito/Matchers.html#isNull(java.lang.Class)">isNull</a>, <a href="../../org/mockito/Matchers.html#longThat(org.hamcrest.Matcher)">longThat</a>, <a href="../../org/mockito/Matchers.html#matches(java.lang.String)">matches</a>, <a href="../../org/mockito/Matchers.html#notNull()">notNull</a>, <a href="../../org/mockito/Matchers.html#notNull(java.lang.Class)">notNull</a>, <a href="../../org/mockito/Matchers.html#refEq(T,%20java.lang.String...)">refEq</a>, <a href="../../org/mockito/Matchers.html#same(T)">same</a>, <a href="../../org/mockito/Matchers.html#shortThat(org.hamcrest.Matcher)">shortThat</a>, <a href="../../org/mockito/Matchers.html#startsWith(java.lang.String)">startsWith</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#clone()" title="class or interface in java.lang">clone</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#finalize()" title="class or interface in java.lang">finalize</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</a>, <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true#wait(long,%20int)" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="RETURNS_DEFAULTS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_DEFAULTS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_DEFAULTS</pre>
<div class="block">The default <code>Answer</code> of every mock <b>if</b> the mock was not stubbed.
 Typically it just returns some empty value.
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a> can be used to define the return values of unstubbed invocations.
 <p>
 This implementation first tries the global configuration.
 If there is no global configuration then it uses <a href="../../org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.html" title="class in org.mockito.internal.stubbing.defaultanswers"><code>ReturnsEmptyValues</code></a> (returns zeros, empty collections, nulls, etc.)</div>
</li>
</ul>
<a name="RETURNS_SMART_NULLS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_SMART_NULLS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_SMART_NULLS</pre>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>.
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a> can be used to define the return values of unstubbed invocations.
 <p>
 This implementation can be helpful when working with legacy code.
 Unstubbed methods often return null. If your code uses the object returned by an unstubbed call you get a NullPointerException.
 This implementation of Answer <b>returns SmartNull instead of null</b>.
 <code>SmartNull</code> gives nicer exception message than NPE because it points out the line where unstubbed method was called. You just click on the stack trace.
 <p>
 <code>ReturnsSmartNulls</code> first tries to return ordinary return values (see <a href="../../org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.html" title="class in org.mockito.internal.stubbing.defaultanswers"><code>ReturnsMoreEmptyValues</code></a>)
 then it tries to return SmartNull. If the return type is final then plain null is returned.
 <p>
 <code>ReturnsSmartNulls</code> will be probably the default return values strategy in Mockito 2.0.
 <p>
 Example:
 <pre class="code"><code class="java">
   Foo mock = (Foo.class, RETURNS_SMART_NULLS);

   //calling unstubbed method here:
   Stuff stuff = mock.getStuff();

   //using object returned by unstubbed call:
   stuff.doSomething();

   //Above doesn't yield NullPointerException this time!
   //Instead, SmartNullPointerException is thrown.
   //Exception's cause links to unstubbed <i>mock.getStuff()</i> - just click on the stack trace.
 </code></pre></div>
</li>
</ul>
<a name="RETURNS_MOCKS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_MOCKS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_MOCKS</pre>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a> can be used to define the return values of unstubbed invocations.
 <p>
 This implementation can be helpful when working with legacy code.
 <p>
 ReturnsMocks first tries to return ordinary return values (see <a href="../../org/mockito/internal/stubbing/defaultanswers/ReturnsMoreEmptyValues.html" title="class in org.mockito.internal.stubbing.defaultanswers"><code>ReturnsMoreEmptyValues</code></a>)
 then it tries to return mocks. If the return type cannot be mocked (e.g. is final) then plain null is returned.
 <p></div>
</li>
</ul>
<a name="RETURNS_DEEP_STUBS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RETURNS_DEEP_STUBS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; RETURNS_DEEP_STUBS</pre>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>.
 <p>
 Example that shows how deep stub works:
 <pre class="code"><code class="java">
   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);

   // note that we're stubbing a chain of methods here: getBar().getName()
   when(mock.getBar().getName()).thenReturn("deep");

   // note that we're chaining method calls: getBar().getName()
   assertEquals("deep", mock.getBar().getName());
 </code></pre>
 </p>

 <p>
 <strong>WARNING: </strong>
 This feature should rarely be required for regular clean code! Leave it for legacy code.
 Mocking a mock to return a mock, to return a mock, (...), to return something meaningful
 hints at violation of Law of Demeter or mocking a value object (a well known anti-pattern).
 </p>

 <p>
 Good quote I've seen one day on the web: <strong>every time a mock returns a mock a fairy dies</strong>.
 </p>

 <p>
 Please note that this answer will return existing mocks that matches the stub. This
 behavior is ok with deep stubs and allows verification to work on the last mock of the chain.
 <pre class="code"><code class="java">
   when(mock.getBar(anyString()).getThingy().getName()).thenReturn("deep");

   mock.getBar("candy bar").getThingy().getName();

   assertSame(mock.getBar(anyString()).getThingy().getName(), mock.getBar(anyString()).getThingy().getName());
   verify(mock.getBar("candy bar").getThingy()).getName();
   verify(mock.getBar(anyString()).getThingy()).getName();
 </code></pre>
 </p>

 <p>
 Verification only works with the last mock in the chain. You can use verification modes.
 <pre class="code"><code class="java">
   when(person.getAddress(anyString()).getStreet().getName()).thenReturn("deep");
   when(person.getAddress(anyString()).getStreet(Locale.ITALIAN).getName()).thenReturn("deep");
   when(person.getAddress(anyString()).getStreet(Locale.CHINESE).getName()).thenReturn("deep");

   person.getAddress("the docks").getStreet().getName();
   person.getAddress("the docks").getStreet().getLongName();
   person.getAddress("the docks").getStreet(Locale.ITALIAN).getName();
   person.getAddress("the docks").getStreet(Locale.CHINESE).getName();

   // note that we are actually referring to the very last mock in the stubbing chain.
   InOrder inOrder = inOrder(
       person.getAddress("the docks").getStreet(),
       person.getAddress("the docks").getStreet(Locale.CHINESE),
       person.getAddress("the docks").getStreet(Locale.ITALIAN)
   );
   inOrder.verify(person.getAddress("the docks").getStreet(), times(1)).getName();
   inOrder.verify(person.getAddress("the docks").getStreet()).getLongName();
   inOrder.verify(person.getAddress("the docks").getStreet(Locale.ITALIAN), atLeast(1)).getName();
   inOrder.verify(person.getAddress("the docks").getStreet(Locale.CHINESE)).getName();
 </code></pre>
 </p>

 <p>
 How deep stub work internally?
 <pre class="code"><code class="java">
   //this:
   Foo mock = mock(Foo.class, RETURNS_DEEP_STUBS);
   when(mock.getBar().getName(), "deep");

   //is equivalent of
   Foo foo = mock(Foo.class);
   Bar bar = mock(Bar.class);
   when(foo.getBar()).thenReturn(bar);
   when(bar.getName()).thenReturn("deep");
 </code></pre>
 </p>

 <p>
 This feature will not work when any return type of methods included in the chain cannot be mocked
 (for example: is a primitive or a final class). This is because of java type system.
 </p></div>
</li>
</ul>
<a name="CALLS_REAL_METHODS">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CALLS_REAL_METHODS</h4>
<pre>public static final&nbsp;<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&lt;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&gt; CALLS_REAL_METHODS</pre>
<div class="block">Optional <code>Answer</code> to be used with <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>
 <p>
 <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a> can be used to define the return values of unstubbed invocations.
 <p>
 This implementation can be helpful when working with legacy code.
 When this implementation is used, unstubbed methods will delegate to the real implementation.
 This is a way to create a partial mock object that calls real methods by default.
 <p>
 As usual you are going to read <b>the partial mock warning</b>:
 Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 How does partial mock fit into this paradigm? Well, it just doesn't...
 Partial mock usually means that the complexity has been moved to a different method on the same object.
 In most cases, this is not the way you want to design your application.
 <p>
 However, there are rare cases when partial mocks come handy:
 dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 <p>
 Example:
 <pre class="code"><code class="java">
 Foo mock = mock(Foo.class, CALLS_REAL_METHODS);

 // this calls the real implementation of Foo.getSomething()
 value = mock.getSomething();

 when(mock.getSomething()).thenReturn(fakeValue);

 // now fakeValue is returned
 value = mock.getSomething();
 </code></pre></div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Mockito()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Mockito</h4>
<pre>public&nbsp;Mockito()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="mock(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mock</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock)</pre>
<div class="block">Creates mock object of given class or interface.
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>classToMock</code> - class or interface to mock</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object</dd></dl>
</li>
</ul>
<a name="mock(java.lang.Class, java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mock</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
         <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;name)</pre>
<div class="block">Specifies mock name. Naming mocks can be helpful for debugging - the name is used in all verification errors.
 <p>
 Beware that naming mocks is not a solution for complex code which uses too many mocks or collaborators.
 <b>If you have too many mocks then refactor the code</b> so that it's easy to test/debug without necessity of naming mocks.
 <p>
 <b>If you use <code>&#064;Mock</code> annotation then you've got naming mocks for free!</b> <code>&#064;Mock</code> uses field name as mock name. <a href="../../org/mockito/Mock.html" title="annotation in org.mockito"><code>Read more.</code></a>
 <p>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>classToMock</code> - class or interface to mock</dd><dd><code>name</code> - of the mock</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object</dd></dl>
</li>
</ul>
<a name="mockingDetails(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mockingDetails</h4>
<pre>public static&nbsp;<a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito">MockingDetails</a>&nbsp;mockingDetails(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toInspect)</pre>
<div class="block">Returns a MockingDetails instance that enables inspecting a particular object for Mockito related information.
 Can be used to find out if given object is a Mockito mock
 or to find out if a given mock is a spy or mock.
 <p>
 In future Mockito versions MockingDetails may grow and provide other useful information about the mock,
 e.g. invocations, stubbing info, etc.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>toInspect</code> - - object to inspect. null input is allowed.</dd>
<dt><span class="strong">Returns:</span></dt><dd>A <a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito"><code>MockingDetails</code></a> instance.</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.9.5</dd></dl>
</li>
</ul>
<a name="mock(java.lang.Class, org.mockito.ReturnValues)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mock</h4>
<pre><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
                    <a href="../../org/mockito/ReturnValues.html" title="interface in org.mockito">ReturnValues</a>&nbsp;returnValues)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i><b>Please use mock(Foo.class, defaultAnswer);</b></i></div>
<div class="block"><b>Deprecated : Please use mock(Foo.class, defaultAnswer);</b>
 <p>
 See <a href="../../org/mockito/Mockito.html#mock(java.lang.Class,%20org.mockito.stubbing.Answer)"><code>mock(Class, Answer)</code></a>
 <p>
 Why it is deprecated? ReturnValues is being replaced by Answer
 for better consistency & interoperability of the framework.
 Answer interface has been in Mockito for a while and it has the same responsibility as ReturnValues.
 There's no point in mainting exactly the same interfaces.
 <p>
 Creates mock with a specified strategy for its return values.
 It's quite advanced feature and typically you don't need it to write decent tests.
 However it can be helpful when working with legacy systems.
 <p>
 Obviously return values are used only when you don't stub the method call.

 <pre class="code"><code class="java">
   Foo mock = mock(Foo.class, Mockito.RETURNS_SMART_NULLS);
   Foo mockTwo = mock(Foo.class, new YourOwnReturnValues());
 </code></pre>

 <p>See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>classToMock</code> - class or interface to mock</dd><dd><code>returnValues</code> - default return values for unstubbed methods</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object</dd></dl>
</li>
</ul>
<a name="mock(java.lang.Class, org.mockito.stubbing.Answer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mock</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
         <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&nbsp;defaultAnswer)</pre>
<div class="block">Creates mock with a specified strategy for its answers to interactions.
 It's quite advanced feature and typically you don't need it to write decent tests.
 However it can be helpful when working with legacy systems.
 <p>
 It is the default answer so it will be used <b>only when you don't</b> stub the method call.

 <pre class="code"><code class="java">
   Foo mock = mock(Foo.class, RETURNS_SMART_NULLS);
   Foo mockTwo = mock(Foo.class, new YourOwnAnswer());
 </code></pre>

 <p>See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>classToMock</code> - class or interface to mock</dd><dd><code>defaultAnswer</code> - default answer for unstubbed methods</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object</dd></dl>
</li>
</ul>
<a name="mock(java.lang.Class, org.mockito.MockSettings)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mock</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;mock(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToMock,
         <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a>&nbsp;mockSettings)</pre>
<div class="block">Creates a mock with some non-standard settings.
 <p>
 The number of configuration points for a mock grows
 so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.
 Hence <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito"><code>MockSettings</code></a>.
 <pre class="code"><code class="java">
   Listener mock = mock(Listener.class, withSettings()
     .name("firstListner").defaultBehavior(RETURNS_SMART_NULLS));
   );
 </code></pre>
 <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?
 Is the code under test so complicated that it requires non-standard mocks?
 Wouldn't you prefer to refactor the code under test so it is testable in a simple way?
 <p>
 See also <a href="../../org/mockito/Mockito.html#withSettings()"><code>withSettings()</code></a>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>classToMock</code> - class or interface to mock</dd><dd><code>mockSettings</code> - additional mock settings</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object</dd></dl>
</li>
</ul>
<a name="spy(java.lang.Object)">
<!--   -->
</a><a name="spy(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spy</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;spy(T&nbsp;object)</pre>
<div class="block">Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed.
 <p>
 Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code.
 <p>
 As usual you are going to read <b>the partial mock warning</b>:
 Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 How does partial mock fit into this paradigm? Well, it just doesn't...
 Partial mock usually means that the complexity has been moved to a different method on the same object.
 In most cases, this is not the way you want to design your application.
 <p>
 However, there are rare cases when partial mocks come handy:
 dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 <p>
 Example:

 <pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //optionally, you can stub out some methods:
   when(spy.size()).thenReturn(100);

   //using the spy calls <b>real</b> methods
   spy.add("one");
   spy.add("two");

   //prints "one" - the first element of a list
   System.out.println(spy.get(0));

   //size() method was stubbed - 100 is printed
   System.out.println(spy.size());

   //optionally, you can verify
   verify(spy).add("one");
   verify(spy).add("two");
 </code></pre>

 <h4>Important gotcha on spying real objects!</h4>
 <ol>
 <li>Sometimes it's impossible or impractical to use <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> for stubbing spies.
 Therefore for spies it is recommended to always use <code>doReturn</code>|<code>Answer</code>|<code>Throw()</code>|<code>CallRealMethod</code>
 family of methods for stubbing. Example:

 <pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo");

   //You have to use doReturn() for stubbing
   doReturn("foo").when(spy).get(0);
 </code></pre>
 </li>

 <li>Mockito <b>*does not*</b> delegate calls to the passed real instance, instead it actually creates a copy of it.
 So if you keep the real instance and interact with it, don't expect the spied to be aware of those interaction
 and their effect on real instance state.
 The corollary is that when an <b>*unstubbed*</b> method is called <b>*on the spy*</b> but <b>*not on the real instance*</b>,
 you won't see any effects on the real instance.</li>

 <li>Watch out for final methods.
 Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble.
 Also you won't be able to verify those method as well.
 </li>
 </ol>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class

 <p>Note that the spy won't have any annotations of the spied type, because CGLIB won't rewrite them.
 It may troublesome for code that rely on the spy to have these annotations.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>object</code> - to spy on</dd>
<dt><span class="strong">Returns:</span></dt><dd>a spy of the real object</dd></dl>
</li>
</ul>
<a name="spy(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spy</h4>
<pre><a href="../../org/mockito/Incubating.html" title="annotation in org.mockito">@Incubating</a>
public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;spy(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;T&gt;&nbsp;classToSpy)</pre>
<div class="block">Please refer to the documentation of <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a>.
 Overusing spies hints at code design smells.
 <p>
 This method, in contrast to the original <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a>, creates a spy based on class instead of an object.
 Sometimes it is more convenient to create spy based on the class and avoid providing an instance of a spied object.
 This is particularly useful for spying on abstract classes because they cannot be instantiated.
 See also <a href="../../org/mockito/MockSettings.html#useConstructor()"><code>MockSettings.useConstructor()</code></a>.
 <p>
 Examples:
 <pre class="code"><code class="java">
   SomeAbstract spy = spy(SomeAbstract.class);

   //Robust API, via settings builder:
   OtherAbstract spy = mock(OtherAbstract.class, withSettings()
      .useConstructor().defaultAnswer(CALLS_REAL_METHODS));

   //Mocking a non-static inner abstract class:
   InnerAbstract spy = mock(InnerAbstract.class, withSettings()
      .useConstructor().outerInstance(outerInstance).defaultAnswer(CALLS_REAL_METHODS));
 </code></pre></div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - type of the spy</dd><dt><span class="strong">Parameters:</span></dt><dd><code>classToSpy</code> - the class to spy</dd>
<dt><span class="strong">Returns:</span></dt><dd>a spy of the provided class</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.10.12</dd></dl>
</li>
</ul>
<a name="stub(java.lang.Object)">
<!--   -->
</a><a name="stub(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stub</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/DeprecatedOngoingStubbing.html" title="interface in org.mockito.stubbing">DeprecatedOngoingStubbing</a>&lt;T&gt;&nbsp;stub(T&nbsp;methodCall)</pre>
<div class="block">Stubs a method call with return value or an exception. E.g:

 <pre class="code"><code class="java">
 stub(mock.someMethod()).toReturn(10);

 //you can use flexible argument matchers, e.g:
 stub(mock.someMethod(<b>anyString()</b>)).toReturn(10);

 //setting exception to be thrown:
 stub(mock.someMethod("some arg")).toThrow(new RuntimeException());

 //you can stub with different behavior for consecutive method calls.
 //Last stubbing (e.g: toReturn("foo")) determines the behavior for further consecutive calls.
 stub(mock.someMethod("some arg"))
  .toThrow(new RuntimeException())
  .toReturn("foo");
 </code></pre>
 <p>
 Some users find stub() confusing therefore <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> is recommended over stub()
 <pre class="code"><code class="java">
   //Instead of:
   stub(mock.count()).toReturn(10);

   //You can do:
   when(mock.count()).thenReturn(10);
 </code></pre>
 For stubbing void methods with throwables see: <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a>
 <p>
 Stubbing can be overridden: for example common stubbing can go to fixture
 setup but the test methods can override it.
 Please note that overridding stubbing is a potential code smell that points out too much stubbing.
 <p>
 Once stubbed, the method will always return stubbed value regardless
 of how many times it is called.
 <p>
 Last stubbing is more important - when you stubbed the same method with
 the same arguments many times.
 <p>
 Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 Let's say you've stubbed foo.bar().
 If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed).
 If your code doesn't care what get(0) returns then it should not be stubbed.
 Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>methodCall</code> - method call</dd>
<dt><span class="strong">Returns:</span></dt><dd>DeprecatedOngoingStubbing object to set stubbed value/exception</dd></dl>
</li>
</ul>
<a name="when(java.lang.Object)">
<!--   -->
</a><a name="when(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>when</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/OngoingStubbing.html" title="interface in org.mockito.stubbing">OngoingStubbing</a>&lt;T&gt;&nbsp;when(T&nbsp;methodCall)</pre>
<div class="block">Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.
 <p>
 Simply put: "<b>When</b> the x method is called <b>then</b> return y".
 <p>
 <b>when() is a successor of deprecated <a href="../../org/mockito/Mockito.html#stub(T)"><code>stub(Object)</code></a></b>
 <p>
 Examples:

 <pre class="code"><code class="java">
 <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);

 //you can use flexible argument matchers, e.g:
 when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);

 //setting exception to be thrown:
 when(mock.someMethod("some arg")).thenThrow(new RuntimeException());

 //you can set different behavior for consecutive method calls.
 //Last stubbing (e.g: thenReturn("foo")) determines the behavior of further consecutive calls.
 when(mock.someMethod("some arg"))
  .thenThrow(new RuntimeException())
  .thenReturn("foo");

 //Alternative, shorter version for consecutive stubbing:
 when(mock.someMethod("some arg"))
  .thenReturn("one", "two");
 //is the same as:
 when(mock.someMethod("some arg"))
  .thenReturn("one")
  .thenReturn("two");

 //shorter version for consecutive method calls throwing exceptions:
 when(mock.someMethod("some arg"))
  .thenThrow(new RuntimeException(), new NullPointerException();

 </code></pre>

 For stubbing void methods with throwables see: <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a>
 <p>
 Stubbing can be overridden: for example common stubbing can go to fixture
 setup but the test methods can override it.
 Please note that overridding stubbing is a potential code smell that points out too much stubbing.
 <p>
 Once stubbed, the method will always return stubbed value regardless
 of how many times it is called.
 <p>
 Last stubbing is more important - when you stubbed the same method with
 the same arguments many times.
 <p>
 Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 Let's say you've stubbed <code>foo.bar()</code>.
 If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).
 If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.
 Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.

 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>methodCall</code> - method to be stubbed</dd>
<dt><span class="strong">Returns:</span></dt><dd>OngoingStubbing object used to stub fluently.
         <strong>Do not</strong> create a reference to this returned object.</dd></dl>
</li>
</ul>
<a name="verify(java.lang.Object)">
<!--   -->
</a><a name="verify(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verify</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;verify(T&nbsp;mock)</pre>
<div class="block">Verifies certain behavior <b>happened once</b>.
 <p>
 Alias to <code>verify(mock, times(1))</code> E.g:
 <pre class="code"><code class="java">
   verify(mock).someMethod("some arg");
 </code></pre>
 Above is equivalent to:
 <pre class="code"><code class="java">
   verify(mock, times(1)).someMethod("some arg");
 </code></pre>
 <p>
 Arguments passed are compared using <code>equals()</code> method.
 Read about <a href="../../org/mockito/ArgumentCaptor.html" title="class in org.mockito"><code>ArgumentCaptor</code></a> or <a href="../../org/mockito/ArgumentMatcher.html" title="class in org.mockito"><code>ArgumentMatcher</code></a> to find out other ways of matching / asserting arguments passed.
 <p>
 Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>.
 Let's say you've stubbed <code>foo.bar()</code>.
 If your code cares what <code>foo.bar()</code> returns then something else breaks(often before even <code>verify()</code> gets executed).
 If your code doesn't care what <code>get(0)</code> returns then it should not be stubbed.
 Not convinced? See <a href="http://monkeyisland.pl/2008/04/26/asking-and-telling">here</a>.

 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mock</code> - to be verified</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object itself</dd></dl>
</li>
</ul>
<a name="verify(java.lang.Object,org.mockito.verification.VerificationMode)">
<!--   -->
</a><a name="verify(T, org.mockito.verification.VerificationMode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verify</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;T&nbsp;verify(T&nbsp;mock,
           <a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;mode)</pre>
<div class="block">Verifies certain behavior happened at least once / exact number of times / never. E.g:
 <pre class="code"><code class="java">
   verify(mock, times(5)).someMethod("was called five times");

   verify(mock, atLeast(2)).someMethod("was called at least two times");

   //you can use flexible argument matchers, e.g:
   verify(mock, atLeastOnce()).someMethod(<b>anyString()</b>);
 </code></pre>

 <b>times(1) is the default</b> and can be omitted
 <p>
 Arguments passed are compared using <code>equals()</code> method.
 Read about <a href="../../org/mockito/ArgumentCaptor.html" title="class in org.mockito"><code>ArgumentCaptor</code></a> or <a href="../../org/mockito/ArgumentMatcher.html" title="class in org.mockito"><code>ArgumentMatcher</code></a> to find out other ways of matching / asserting arguments passed.
 <p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mock</code> - to be verified</dd><dd><code>mode</code> - times(x), atLeastOnce() or never()</dd>
<dt><span class="strong">Returns:</span></dt><dd>mock object itself</dd></dl>
</li>
</ul>
<a name="reset(java.lang.Object[])">
<!--   -->
</a><a name="reset(T...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>reset</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;void&nbsp;reset(T...&nbsp;mocks)</pre>
<div class="block">Smart Mockito users hardly use this feature because they know it could be a sign of poor tests.
 Normally, you don't need to reset your mocks, just create new mocks for each test method.
 <p>
 Instead of <code>#reset()</code> please consider writing simple, small and focused test methods over lengthy, over-specified tests.
 <b>First potential code smell is <code>reset()</code> in the middle of the test method.</b> This probably means you're testing too much.
 Follow the whisper of your test methods: "Please keep us small & focused on single behavior".
 There are several threads about it on mockito mailing list.
 <p>
 The only reason we added <code>reset()</code> method is to
 make it possible to work with container-injected mocks.
 See issue 55 (<a href="http://code.google.com/p/mockito/issues/detail?id=55">here</a>)
 or FAQ (<a href="http://code.google.com/p/mockito/wiki/FAQ">here</a>).
 <p>
 <b>Don't harm yourself.</b> <code>reset()</code> in the middle of the test method is a code smell (you're probably testing too much).
 <pre class="code"><code class="java">
   List mock = mock(List.class);
   when(mock.size()).thenReturn(10);
   mock.add(1);

   reset(mock);
   //at this point the mock forgot any interactions & stubbing
 </code></pre></div>
<dl><dt><span class="strong">Type Parameters:</span></dt><dd><code>T</code> - The Type of the mocks</dd><dt><span class="strong">Parameters:</span></dt><dd><code>mocks</code> - to be reset</dd></dl>
</li>
</ul>
<a name="verifyNoMoreInteractions(java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verifyNoMoreInteractions</h4>
<pre>public static&nbsp;void&nbsp;verifyNoMoreInteractions(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">Checks if any of given mocks has any unverified interaction.
 <p>
 You can use this method after you verified your mocks - to make sure that nothing
 else was invoked on your mocks.
 <p>
 See also <a href="../../org/mockito/Mockito.html#never()"><code>never()</code></a> - it is more explicit and communicates the intent well.
 <p>
 Stubbed invocations (if called) are also treated as interactions.
 <p>
 A word of <b>warning</b>:
 Some users who did a lot of classic, expect-run-verify mocking tend to use <code>verifyNoMoreInteractions()</code> very often, even in every test method.
 <code>verifyNoMoreInteractions()</code> is not recommended to use in every test method.
 <code>verifyNoMoreInteractions()</code> is a handy assertion from the interaction testing toolkit. Use it only when it's relevant.
 Abusing it leads to overspecified, less maintainable tests. You can find further reading
 <a href="http://monkeyisland.pl/2008/07/12/should-i-worry-about-the-unexpected/">here</a>.
 <p>
 This method will also detect unverified invocations that occurred before the test method,
 for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.
 Consider writing nice code that makes interactions only in test methods.

 <p>
 Example:

 <pre class="code"><code class="java">
 //interactions
 mock.doSomething();
 mock.doSomethingUnexpected();

 //verification
 verify(mock).doSomething();

 //following will fail because 'doSomethingUnexpected()' is unexpected
 verifyNoMoreInteractions(mock);

 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mocks</code> - to be verified</dd></dl>
</li>
</ul>
<a name="verifyZeroInteractions(java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>verifyZeroInteractions</h4>
<pre>public static&nbsp;void&nbsp;verifyZeroInteractions(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">Verifies that no interactions happened on given mocks.
 <pre class="code"><code class="java">
   verifyZeroInteractions(mockOne, mockTwo);
 </code></pre>
 This method will also detect invocations
 that occurred before the test method, for example: in <code>setUp()</code>, <code>&#064;Before</code> method or in constructor.
 Consider writing nice code that makes interactions only in test methods.
 <p>
 See also <a href="../../org/mockito/Mockito.html#never()"><code>never()</code></a> - it is more explicit and communicates the intent well.
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mocks</code> - to be verified</dd></dl>
</li>
</ul>
<a name="stubVoid(java.lang.Object)">
<!--   -->
</a><a name="stubVoid(T)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stubVoid</h4>
<pre>public static&nbsp;&lt;T&gt;&nbsp;<a href="../../org/mockito/stubbing/VoidMethodStubbable.html" title="interface in org.mockito.stubbing">VoidMethodStubbable</a>&lt;T&gt;&nbsp;stubVoid(T&nbsp;mock)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Use <a href="../../org/mockito/Mockito.html#doThrow(java.lang.Throwable)"><code>doThrow(Throwable)</code></a> method for stubbing voids</i></div>
<div class="block"><pre class="code"><code class="java">
   //Instead of:
   stubVoid(mock).toThrow(e).on().someVoidMethod();

   //Please do:
   doThrow(e).when(mock).someVoidMethod();
 </code></pre>

 doThrow() replaces stubVoid() because of improved readability and consistency with the family of doAnswer() methods.
 <p>
 Originally, <code>stubVoid()</code> was used for stubbing void methods with exceptions. E.g:

 <pre class="code"><code class="java">
 stubVoid(mock).toThrow(new RuntimeException()).on().someMethod();

 //you can stub with different behavior for consecutive calls.
 //Last stubbing (e.g. toReturn()) determines the behavior for further consecutive calls.
 stubVoid(mock)
   .toThrow(new RuntimeException())
   .toReturn()
   .on().someMethod();
 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mock</code> - to stub</dd>
<dt><span class="strong">Returns:</span></dt><dd>stubbable object that allows stubbing with throwable</dd></dl>
</li>
</ul>
<a name="doThrow(java.lang.Throwable)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doThrow</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doThrow(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&nbsp;toBeThrown)</pre>
<div class="block">Use <code>doThrow()</code> when you want to stub the void method with an exception.
 <p>
 Stubbing voids requires different approach from <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> because the compiler does not like void methods inside brackets...
 <p>
 Example:

 <pre class="code"><code class="java">
   doThrow(new RuntimeException()).when(mock).someVoidMethod();
 </code></pre></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>toBeThrown</code> - to be thrown when the stubbed method is called</dd>
<dt><span class="strong">Returns:</span></dt><dd>stubber - to select a method for stubbing</dd></dl>
</li>
</ul>
<a name="doThrow(java.lang.Class)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doThrow</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doThrow(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Class.html?is-external=true" title="class or interface in java.lang">Class</a>&lt;? extends <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html?is-external=true" title="class or interface in java.lang">Throwable</a>&gt;&nbsp;toBeThrown)</pre>
<div class="block">Use <code>doThrow()</code> when you want to stub the void method to throw exception of specified class.
 <p>
 A new exception instance will be created for each method invocation.
 <p>
 Stubbing voids requires different approach from <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> because the compiler does not like void methods inside brackets...
 <p>
 Example:

 <pre class="code"><code class="java">
   doThrow(RuntimeException.class).when(mock).someVoidMethod();
 </code></pre></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>toBeThrown</code> - to be thrown when the stubbed method is called</dd>
<dt><span class="strong">Returns:</span></dt><dd>stubber - to select a method for stubbing</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.9.0</dd></dl>
</li>
</ul>
<a name="doCallRealMethod()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doCallRealMethod</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doCallRealMethod()</pre>
<div class="block">Use <code>doCallRealMethod()</code> when you want to call the real implementation of a method.
 <p>
 As usual you are going to read <b>the partial mock warning</b>:
 Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects.
 How does partial mock fit into this paradigm? Well, it just doesn't...
 Partial mock usually means that the complexity has been moved to a different method on the same object.
 In most cases, this is not the way you want to design your application.
 <p>
 However, there are rare cases when partial mocks come handy:
 dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.)
 However, I wouldn't use partial mocks for new, test-driven & well-designed code.
 <p>
 See also javadoc <a href="../../org/mockito/Mockito.html#spy(T)"><code>spy(Object)</code></a> to find out more about partial mocks.
 <b>Mockito.spy() is a recommended way of creating partial mocks.</b>
 The reason is it guarantees real methods are called against correctly constructed object because you're responsible for constructing the object passed to spy() method.
 <p>
 Example:
 <pre class="code"><code class="java">
   Foo mock = mock(Foo.class);
   doCallRealMethod().when(mock).someVoidMethod();

   // this will call the real implementation of Foo.someVoidMethod()
   mock.someVoidMethod();
 </code></pre>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>stubber - to select a method for stubbing</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.9.5</dd></dl>
</li>
</ul>
<a name="doAnswer(org.mockito.stubbing.Answer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doAnswer</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doAnswer(<a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing">Answer</a>&nbsp;answer)</pre>
<div class="block">Use <code>doAnswer()</code> when you want to stub a void method with generic <a href="../../org/mockito/stubbing/Answer.html" title="interface in org.mockito.stubbing"><code>Answer</code></a>.
 <p>
 Stubbing voids requires different approach from <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> because the compiler does not like void methods inside brackets...
 <p>
 Example:

 <pre class="code"><code class="java">
  doAnswer(new Answer() {
      public Object answer(InvocationOnMock invocation) {
          Object[] args = invocation.getArguments();
          Mock mock = invocation.getMock();
          return null;
      }})
  .when(mock).someMethod();
 </code></pre>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>answer</code> - to answer when the stubbed method is called</dd>
<dt><span class="strong">Returns:</span></dt><dd>stubber - to select a method for stubbing</dd></dl>
</li>
</ul>
<a name="doNothing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doNothing</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doNothing()</pre>
<div class="block">Use <code>doNothing()</code> for setting void methods to do nothing. <b>Beware that void methods on mocks do nothing by default!</b>
 However, there are rare situations when doNothing() comes handy:
 <p>
 <ol>
 <li>Stubbing consecutive calls on a void method:
 <pre class="code"><code class="java">
   doNothing().
   doThrow(new RuntimeException())
   .when(mock).someVoidMethod();

   //does nothing the first time:
   mock.someVoidMethod();

   //throws RuntimeException the next time:
   mock.someVoidMethod();
 </code></pre>
 </li>
 <li>When you spy real objects and you want the void method to do nothing:
 <pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //let's make clear() do nothing
   doNothing().when(spy).clear();

   spy.add("one");

   //clear() does nothing, so the list still contains "one"
   spy.clear();
 </code></pre>
 </li>
 </ol>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>stubber - to select a method for stubbing</dd></dl>
</li>
</ul>
<a name="doReturn(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>doReturn</h4>
<pre>public static&nbsp;<a href="../../org/mockito/stubbing/Stubber.html" title="interface in org.mockito.stubbing">Stubber</a>&nbsp;doReturn(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;toBeReturned)</pre>
<div class="block">Use <code>doReturn()</code> in those rare occasions when you cannot use <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a>.
 <p>
 <b>Beware that <a href="../../org/mockito/Mockito.html#when(T)"><code>when(Object)</code></a> is always recommended for stubbing because it is argument type-safe
 and more readable</b> (especially when stubbing consecutive calls).
 <p>
 Here are those rare occasions when doReturn() comes handy:
 <p>

 <ol>
 <li>When spying real objects and calling real methods on a spy brings side effects

 <pre class="code"><code class="java">
   List list = new LinkedList();
   List spy = spy(list);

   //Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty)
   when(spy.get(0)).thenReturn("foo");

   //You have to use doReturn() for stubbing:
   doReturn("foo").when(spy).get(0);
 </code></pre>
 </li>

 <li>Overriding a previous exception-stubbing:
 <pre class="code"><code class="java">
   when(mock.foo()).thenThrow(new RuntimeException());

   //Impossible: the exception-stubbed foo() method is called so RuntimeException is thrown.
   when(mock.foo()).thenReturn("bar");

   //You have to use doReturn() for stubbing:
   doReturn("bar").when(mock).foo();
 </code></pre>
 </li>
 </ol>

 Above scenarios shows a tradeoff of Mockito's elegant syntax. Note that the scenarios are very rare, though.
 Spying should be sporadic and overriding exception-stubbing is very rare. Not to mention that in general
 overridding stubbing is a potential code smell that points out too much stubbing.
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>toBeReturned</code> - to be returned when the stubbed method is called</dd>
<dt><span class="strong">Returns:</span></dt><dd>stubber - to select a method for stubbing</dd></dl>
</li>
</ul>
<a name="inOrder(java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>inOrder</h4>
<pre>public static&nbsp;<a href="../../org/mockito/InOrder.html" title="interface in org.mockito">InOrder</a>&nbsp;inOrder(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">Creates <a href="../../org/mockito/InOrder.html" title="interface in org.mockito"><code>InOrder</code></a> object that allows verifying mocks in order.

 <pre class="code"><code class="java">
   InOrder inOrder = inOrder(firstMock, secondMock);

   inOrder.verify(firstMock).add("was called first");
   inOrder.verify(secondMock).add("was called second");
 </code></pre>

 Verification in order is flexible - <b>you don't have to verify all interactions</b> one-by-one
 but only those that you are interested in testing in order.
 <p>
 Also, you can create InOrder object passing only mocks that are relevant for in-order verification.
 <p>
 <code>InOrder</code> verification is 'greedy'. You will hardly every notice it but
 if you want to find out more search for 'greedy' on the Mockito
 <a href="http://code.google.com/p/mockito/w/list">wiki pages</a>.
 <p>
 As of Mockito 1.8.4 you can verifyNoMoreInvocations() in order-sensitive way. Read more: <a href="../../org/mockito/InOrder.html#verifyNoMoreInteractions()"><code>InOrder.verifyNoMoreInteractions()</code></a>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mocks</code> - to be verified in order</dd>
<dt><span class="strong">Returns:</span></dt><dd>InOrder object to be used to verify in order</dd></dl>
</li>
</ul>
<a name="ignoreStubs(java.lang.Object...)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ignoreStubs</h4>
<pre>public static&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>[]&nbsp;ignoreStubs(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>...&nbsp;mocks)</pre>
<div class="block">Ignores stubbed methods of given mocks for the sake of verification.
 Sometimes useful when coupled with <code>verifyNoMoreInteractions()</code> or verification <code>inOrder()</code>.
 Helps avoiding redundant verification of stubbed calls - typically we're not interested in verifying stubs.
 <p>
 <b>Warning</b>, <code>ignoreStubs()</code> might lead to overuse of <code>verifyNoMoreInteractions(ignoreStubs(...));</code>
 Bear in mind that Mockito does not recommend bombarding every test with <code>verifyNoMoreInteractions()</code>
 for the reasons outlined in javadoc for <a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)"><code>verifyNoMoreInteractions(Object...)</code></a>
 Other words: all <b>*stubbed*</b> methods of given mocks are marked <b>*verified*</b> so that they don't get in a way during verifyNoMoreInteractions().
 <p>
 This method <b>changes the input mocks</b>! This method returns input mocks just for convenience.
 <p>
 Ignored stubs will also be ignored for verification inOrder, including <a href="../../org/mockito/InOrder.html#verifyNoMoreInteractions()"><code>InOrder.verifyNoMoreInteractions()</code></a>.
 See the second example.
 <p>
 Example:
 <pre class="code"><code class="java">
  //mocking lists for the sake of the example (if you mock List in real you will burn in hell)
  List mock1 = mock(List.class), mock2 = mock(List.class);

  //stubbing mocks:
  when(mock1.get(0)).thenReturn(10);
  when(mock2.get(0)).thenReturn(20);

  //using mocks by calling stubbed get(0) methods:
  System.out.println(mock1.get(0)); //prints 10
  System.out.println(mock2.get(0)); //prints 20

  //using mocks by calling clear() methods:
  mock1.clear();
  mock2.clear();

  //verification:
  verify(mock1).clear();
  verify(mock2).clear();

  //verifyNoMoreInteractions() fails because get() methods were not accounted for.
  try { verifyNoMoreInteractions(mock1, mock2); } catch (NoInteractionsWanted e);

  //However, if we ignore stubbed methods then we can verifyNoMoreInteractions()
  verifyNoMoreInteractions(ignoreStubs(mock1, mock2));

  //Remember that ignoreStubs() <b>*changes*</b> the input mocks and returns them for convenience.
 </code></pre>
 Ignoring stubs can be used with <b>verification in order</b>:
 <pre class="code"><code class="java">
  List list = mock(List.class);
  when(mock.get(0)).thenReturn("foo");

  list.add(0);
  System.out.println(list.get(0)); //we don't want to verify this
  list.clear();

  InOrder inOrder = inOrder(ignoreStubs(list));
  inOrder.verify(list).add(0);
  inOrder.verify(list).clear();
  inOrder.verifyNoMoreInteractions();
 </code></pre></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>mocks</code> - input mocks that will be changed</dd>
<dt><span class="strong">Returns:</span></dt><dd>the same mocks that were passed in as parameters</dd><dt><span class="strong">Since:</span></dt>
  <dd>1.9.0</dd></dl>
</li>
</ul>
<a name="times(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>times</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;times(int&nbsp;wantedNumberOfInvocations)</pre>
<div class="block">Allows verifying exact number of invocations. E.g:
 <pre class="code"><code class="java">
   verify(mock, times(2)).someMethod("some arg");
 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>wantedNumberOfInvocations</code> - wanted number of invocations</dd>
<dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="never()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>never</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;never()</pre>
<div class="block">Alias to <code>times(0)</code>, see <a href="../../org/mockito/Mockito.html#times(int)"><code>times(int)</code></a>
 <p>
 Verifies that interaction did not happen. E.g:
 <pre class="code"><code class="java">
   verify(mock, never()).someMethod();
 </code></pre>

 <p>
 If you want to verify there were NO interactions with the mock
 check out <a href="../../org/mockito/Mockito.html#verifyZeroInteractions(java.lang.Object...)"><code>verifyZeroInteractions(Object...)</code></a>
 or <a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)"><code>verifyNoMoreInteractions(Object...)</code></a>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="atLeastOnce()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atLeastOnce</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atLeastOnce()</pre>
<div class="block">Allows at-least-once verification. E.g:
 <pre class="code"><code class="java">
   verify(mock, atLeastOnce()).someMethod("some arg");
 </code></pre>
 Alias to <code>atLeast(1)</code>.
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="atLeast(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atLeast</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atLeast(int&nbsp;minNumberOfInvocations)</pre>
<div class="block">Allows at-least-x verification. E.g:
 <pre class="code"><code class="java">
   verify(mock, atLeast(3)).someMethod("some arg");
 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>minNumberOfInvocations</code> - minimum number of invocations</dd>
<dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="atMost(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atMost</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;atMost(int&nbsp;maxNumberOfInvocations)</pre>
<div class="block">Allows at-most-x verification. E.g:
 <pre class="code"><code class="java">
   verify(mock, atMost(3)).someMethod("some arg");
 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>maxNumberOfInvocations</code> - max number of invocations</dd>
<dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="calls(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>calls</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;calls(int&nbsp;wantedNumberOfInvocations)</pre>
<div class="block">Allows non-greedy verification in order.  For example
 <pre class="code"><code class="java">
   inOrder.verify( mock, calls( 2 )).someMethod( "some arg" );
 </code></pre>
 <ul>
 <li>will not fail if the method is called 3 times, unlike times( 2 )</li>
 <li>will not mark the third invocation as verified, unlike atLeast( 2 )</li>
 </ul>
 This verification mode can only be used with in order verification.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>wantedNumberOfInvocations</code> - number of invocations to verify</dd>
<dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="only()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>only</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationMode.html" title="interface in org.mockito.verification">VerificationMode</a>&nbsp;only()</pre>
<div class="block">Allows checking if given method was the only one invoked. E.g:
 <pre class="code"><code class="java">
   verify(mock, only()).someMethod();
   //above is a shorthand for following 2 lines of code:
   verify(mock).someMethod();
   verifyNoMoreInvocations(mock);
 </code></pre>

 <p>
 See also <a href="../../org/mockito/Mockito.html#verifyNoMoreInteractions(java.lang.Object...)"><code>verifyNoMoreInteractions(Object...)</code></a>
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="timeout(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>timeout</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationWithTimeout.html" title="interface in org.mockito.verification">VerificationWithTimeout</a>&nbsp;timeout(long&nbsp;millis)</pre>
<div class="block">Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired
 interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent
 conditions.
 <p>
 This differs from <a href="../../org/mockito/Mockito.html#after(long)"><code>after()</code></a> in that after() will wait the full period, unless
 the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon
 as verification passes, producing different behaviour when used with times(2), for example, which can pass
 and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until
 times(2) failed, and then fail.
 <p>
 It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system
 <p>
 Not yet implemented to work with InOrder verification.
 <pre class="code"><code class="java">
   //passes when someMethod() is called within given time span
   verify(mock, timeout(100)).someMethod();
   //above is an alias to:
   verify(mock, timeout(100).times(1)).someMethod();

   //passes as soon as someMethod() has been called 2 times before the given timeout
   verify(mock, timeout(100).times(2)).someMethod();

   //equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout
   verify(mock, timeout(100).atLeast(2)).someMethod();

   //verifies someMethod() within given time span using given verification mode
   //useful only if you have your own custom verification modes.
   verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod();
 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>millis</code> - - time span in milliseconds</dd>
<dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="after(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>after</h4>
<pre>public static&nbsp;<a href="../../org/mockito/verification/VerificationAfterDelay.html" title="interface in org.mockito.verification">VerificationAfterDelay</a>&nbsp;after(long&nbsp;millis)</pre>
<div class="block">Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired
 interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent
 conditions.
 <p>
 This differs from <a href="../../org/mockito/Mockito.html#timeout(long)"><code>timeout()</code></a> in that after() will wait the full period, whereas timeout()
 will stop early as soon as verification passes, producing different behaviour when used with times(2), for example,
 which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would
 run the full time, which point it will fail, as times(2) has failed.
 <p>
 It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system
 <p>
 Not yet implemented to work with InOrder verification.
 <pre class="code"><code class="java">
   //passes after 100ms, if someMethod() has only been called once at that time.
   verify(mock, after(100)).someMethod();
   //above is an alias to:
   verify(mock, after(100).times(1)).someMethod();

   //passes if someMethod() is called <b>*exactly*</b> 2 times after the given timespan
   verify(mock, after(100).times(2)).someMethod();

   //passes if someMethod() has not been called after the given timespan
   verify(mock, after(100).never()).someMethod();

   //verifies someMethod() after a given time span using given verification mode
   //useful only if you have your own custom verification modes.
   verify(mock, new After(100, yourOwnVerificationMode)).someMethod();
 </code></pre>

 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>millis</code> - - time span in milliseconds</dd>
<dt><span class="strong">Returns:</span></dt><dd>verification mode</dd></dl>
</li>
</ul>
<a name="validateMockitoUsage()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validateMockitoUsage</h4>
<pre>public static&nbsp;void&nbsp;validateMockitoUsage()</pre>
<div class="block">First of all, in case of any trouble, I encourage you to read the Mockito FAQ: <a href="http://code.google.com/p/mockito/wiki/FAQ">http://code.google.com/p/mockito/wiki/FAQ</a>
 <p>
 In case of questions you may also post to mockito mailing list: <a href="http://groups.google.com/group/mockito">http://groups.google.com/group/mockito</a>
 <p>
 <code>validateMockitoUsage()</code> <b>explicitly validates</b> the framework state to detect invalid use of Mockito.
 However, this feature is optional <b>because Mockito validates the usage all the time...</b> but there is a gotcha so read on.
 <p>
 Examples of incorrect use:
 <pre class="code"><code class="java">
 //Oops, thenReturn() part is missing:
 when(mock.get());

 //Oops, verified method call is inside verify() where it should be on the outside:
 verify(mock.execute());

 //Oops, missing method to verify:
 verify(mock);
 </code></pre>

 Mockito throws exceptions if you misuse it so that you know if your tests are written correctly.
 The gotcha is that Mockito does the validation <b>next time</b> you use the framework (e.g. next time you verify, stub, call mock etc.).
 But even though the exception might be thrown in the next test,
 the exception <b>message contains a navigable stack trace element</b> with location of the defect.
 Hence you can click and find the place where Mockito was misused.
 <p>
 Sometimes though, you might want to validate the framework usage explicitly.
 For example, one of the users wanted to put <code>validateMockitoUsage()</code> in his <code>&#064;After</code> method
 so that he knows immediately when he misused Mockito.
 Without it, he would have known about it not sooner than <b>next time</b> he used the framework.
 One more benefit of having <code>validateMockitoUsage()</code> in <code>&#064;After</code> is that jUnit runner and rule will always fail in the test method with defect
 whereas ordinary 'next-time' validation might fail the <b>next</b> test method.
 But even though JUnit might report next test as red, don't worry about it
 and just click at navigable stack trace element in the exception message to instantly locate the place where you misused mockito.
 <p>
 <b>Both built-in runner: <a href="../../org/mockito/runners/MockitoJUnitRunner.html" title="class in org.mockito.runners"><code>MockitoJUnitRunner</code></a> and rule: <a href="../../org/mockito/junit/MockitoRule.html" title="interface in org.mockito.junit"><code>MockitoRule</code></a></b> do validateMockitoUsage() after each test method.
 <p>
 Bear in mind that <b>usually you don't have to <code>validateMockitoUsage()</code></b>
 and framework validation triggered on next-time basis should be just enough,
 mainly because of enhanced exception message with clickable location of defect.
 However, I would recommend validateMockitoUsage() if you already have sufficient test infrastructure
 (like your own runner or base class for all tests) because adding a special action to <code>&#064;After</code> has zero cost.
 <p>
 See examples in javadoc for <a href="../../org/mockito/Mockito.html" title="class in org.mockito"><code>Mockito</code></a> class</div>
</li>
</ul>
<a name="withSettings()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>withSettings</h4>
<pre>public static&nbsp;<a href="../../org/mockito/MockSettings.html" title="interface in org.mockito">MockSettings</a>&nbsp;withSettings()</pre>
<div class="block">Allows mock creation with additional mock settings.
 <p>
 Don't use it too often.
 Consider writing simple tests that use simple mocks.
 Repeat after me: simple tests push simple, KISSy, readable & maintainable code.
 If you cannot write a test in a simple way - refactor the code under test.
 <p>
 Examples of mock settings:
 <pre class="code"><code class="java">
   //Creates mock with different default answer & name
   Foo mock = mock(Foo.class, withSettings()
       .defaultAnswer(RETURNS_SMART_NULLS)
       .name("cool mockie"));

   //Creates mock with different default answer, descriptive name and extra interfaces
   Foo mock = mock(Foo.class, withSettings()
       .defaultAnswer(RETURNS_SMART_NULLS)
       .name("cool mockie")
       .extraInterfaces(Bar.class));
 </code></pre>
 <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito"><code>MockSettings</code></a> has been introduced for two reasons.
 Firstly, to make it easy to add another mock settings when the demand comes.
 Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods.
 <p>
 See javadoc for <a href="../../org/mockito/MockSettings.html" title="interface in org.mockito"><code>MockSettings</code></a> to learn about possible mock settings.
 <p></div>
<dl><dt><span class="strong">Returns:</span></dt><dd>mock settings instance with defaults.</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Mockito.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-files/index-1.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
<div class="aboutLanguage"><em>
<em id="mockito-version-header-javadoc7"><strong>Mockito 2.0.12-beta API</strong></em>

<!-- using the beautify plugin for jQuery from https://bitbucket.org/larscorneliussen/beautyofcode/ -->
<script type="text/javascript">
  var shBaseURL = "../../js/sh-2.1.382/";
</script>
<script type="text/javascript" src="../../js/jquery-1.7.min.js"></script>
<script type="text/javascript" src="../../js/jquery.beautyOfCode-min.js"></script>

<script type="text/javascript">
  /* Apply beautification of code */
  var usingOldIE = false;
  if($.browser.msie && parseInt($.browser.version) < 9) usingOldIE = true;

  if(!usingOldIE) {
      $.beautyOfCode.init({
        theme : "Eclipse",
        brushes: ["Java"]
      });

      var version = "2.0.12-beta";

      jQuery.fn.removeAttributes = function() {
        return this.each(function() {
          var attributes = $.map(this.attributes, function(item) {
            return item.name;
          });
          var img = $(this);
          $.each(attributes, function(i, item) {
            img.removeAttr(item);
          });
        });
      };

      $(function() {
        /* Add name & version to header for Javadoc 1.6 */
        $("td.NavBarCell1[colspan=2]").each(function(index, element) {
          var jqueryTD = $(element);
          jqueryTD.after(
            $("<td><em><strong>Mockito 2.0.12-beta API</strong></em></td>").attr("class","NavBarCell1").attr("id","mockito-version-header-javadoc6")
          );
          jqueryTD.removeAttr("colspan");
        });
        /* Cleans up mess with Javadoc 1.7 */
        $("body > h1").removeAttributes().attr("class", "bar").attr("title", "Mockito 2.0.12-beta API");
        /* Cleans up mess with Javadoc 1.7 with Javadoc 1.6 */
        $("td em#mockito-version-header-javadoc7").remove();
      });
  }
</script>
</em></div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../org/mockito/MockingDetails.html" title="interface in org.mockito"><span class="strong">Prev Class</span></a></li>
<li><a href="../../org/mockito/MockitoAnnotations.html" title="class in org.mockito"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?org/mockito/Mockito.html" target="_top">Frames</a></li>
<li><a href="Mockito.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Mockito, MIT License</small></p>
</body>
</html>
